# Copyright (C) 2017-2018  Arne A.N. Bruyneel
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#' @title Set the configuration parameters for executing an analysis
#' @description This function will generate a configuration list based on the provided arguments. This list will have the provide in further analysis steps.
#' @param samples Table with all samples entries, as generated by AlleleProfileR.read.folders.
#' @param genes Path to the .csv file containing all gene entries.
#' @param index Path to the .fa file containing the reference genome.
#' @param cutoff Percent value (0 to 1), representing the treshold read count for a certain allelic variant to be included in further analysis.
#' @param ignore.snp Ignore SNPs? Default is FALSE.
#' @param ignore.single Ingore alleles representing a single read pair? Default is FALSE.
#' @param ignore.chimeric Ignore chimeric reads? Default is FALSE.
#' @param cut.range Range around cut site for considering NHEJ. Default is 0, this setting will disregard cut range.
#' @param alternate List of alternate objects for all samples (in order), NULL if not used.
#' @param cutoff.large Cutoff value for determining whether an indel is large or small. Default is 25.
#' @param chimeric.max.insertion.size Max insertion size when inspecting chemeric alignments. Default is 50.
#' @param suppress.messages Suppress messages? Default is FALSE.
#' @return list
#' @author Arne Bruyneel
#' @export
AlleleProfileR.setup <- function(samples, genes, index, cutoff=0.02,
                                 ignore.snp = F, ignore.single = F, ignore.chimeric = F,
                                 cut.range = 0, alternate = NULL, cutoff.large = 25,
                                 chimeric.max.insertion.size = 50, suppress.messages = F) {
  # the idea is that the user would populated a csv file with information on the files, genes, and provide additional experimental parameters
  if (!is.data.frame(samples) || is.na(genes) || is.na(index)) {
    stop("Please complete both sample and gene tables")
  } else {
    samplestable <- samples
    genestable <- read.csv(genes, header = T)

    genestable$Gene <- as.character(genestable$Gene)
    genestable$Chr <- as.character(genestable$Chr)
    genestable$StartType <- as.character(genestable$StartType)
    genestable$StopType <- as.character(genestable$StopType)

    for (g in 1:dim(genestable)[1]) {
      if (is.na(genestable$StopCodon[g])) {
        genestable$StopCodon[g] <- genestable$Stop[g]
      }
    }

    # is the index generated?
    if(!file.exists(paste(index,".fai", sep=""))) {
      bwa_index <- index

      # samtools faidxand bwa index
      cmd1 <- paste0("samtools faidx ", bwa_index)
      cmd2 <- paste0("bwa index ", bwa_index)
      message(cmd1, "\n");
      system(cmd1)
      message(cmd2, "\n");
      system(cmd2)
    }

    return(list(samplestable, genestable, index, cutoff, ignore.snp, ignore.single, cut.range,
                alternate, ignore.chimeric, cutoff.large, chimeric.max.insertion.size, suppress.messages))
  }
}

#' @title Start the analysis pipeline
#' @description This is the main function for processing the sequencing data to determine genetic variants.
#' @param config Configuration list, as generated by AlleleProfileR.setup.
#' @param cores Number of CPU cores to be used for processing.
#' @param subset List of the IDs of samples table and the IDs of the genes of interest in the genes table. If set to NULL, all samples will be analysed for all genes. Default is NULL.
#' @param summarize Generate ummary tables and exported as .csv files. Default is TRUE.
#' @inheritParams AlleleProfileR.map
#' @return This function does not return anything. All results are written to .csv files in the output folder.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.batch <- function(config, cores = 1, subset = NULL, summarize = TRUE) {
  # determine the subset parameters
  # collect the data
  if (is.list(subset)) {
    if (length(subset) == 2) {
      soi <- subset[[1]]
      goi <- subset[[2]]

      samplestable <- config[[1]][soi,]
      genestable <- config[[2]][goi,]
    } else {
      stop("Illegal subset parameters")
    }

  } else {
    if (is.null(subset)) {
      samplestable <- config[[1]]
      genestable <- config[[2]]
    } else {
      stop("Illegal subset parameters")
    }
  }

  cutoff <- config[[4]]
  index <- config[[3]]
  ignore.snp <- config[[5]]
  ignore.single <- config[[6]]
  cut.range <- config[[7]]
  ignore.chimeric <- config[[9]]
  cutoff.large <- config[[10]]
  chimeric.max.insertion.size <- config[[11]]
  suppress.messages <- config[[12]]

  # make a job list
  joblist <- list()
  r <- 1
  for (i in 1:dim(samplestable)[1]) {
    for(j in 1:dim(genestable)[1]) {
      joblist[[r]] <- c(i,j)
      r <- r + 1
    }
  }

  #
  executejob <- function(bamobj_clean, samplestable, genestable, job, cutoff, index,
                         ignore.snp, ignore.single, summarize, cut.range, cutoff.large,
                         ignore.chimeric, chimeric.max.insertion.size, suppress.messages) {

    bamobj <- AlleleProfileR.bam(paste(samplestable$bam[job[1]], sep=""))
    bamobj_clean <- AlleleProfileR.qc.simple(bamobj)
    AlleleProfileR.execute(bamobj_clean, samplestable, genestable, job[1], job[2],
                           cutoff, index, ignore.snp, ignore.single, summarize,
                           cut.range, cutoff.large, ignore.chimeric,
                           chimeric.max.insertion.size, suppress.messages)
  }

  # compile
  executejobcmp <- compiler::cmpfun(executejob)

  # loop through joblist, use multiple cores if requested
  if (cores > 1) {
    if (!suppress.messages) {
      cat("Please be patient - no status updates when using parallel computing... \n")
    }

    #
    `%dopar%` <- foreach::`%dopar%`
    no_cores <- min(cores, parallel::detectCores() - 1)
    cl <- parallel::makeCluster(no_cores, type="FORK")
    doParallel::registerDoParallel(cl)
    foreach::foreach(k=1:length(joblist)) %dopar% executejobcmp(bamobj_clean, samplestable, genestable, joblist[[k]],
                                                                cutoff, index, ignore.snp, ignore.single, summarize,
                                                                cut.range, cutoff.large, ignore.chimeric, chimeric.max.insertion.size,
                                                                suppress.messages)
    parallel::stopCluster(cl)
  } else {
    for(k in 1:length(joblist)) {
      executejobcmp(bamobj_clean, samplestable, genestable, joblist[[k]],
                    cutoff, index, ignore.snp, ignore.single, summarize,
                    cut.range, cutoff.large, ignore.chimeric, chimeric.max.insertion.size,
                    suppress.messages)
    }
  }
}

#' @title Read folders for .fastq or .bam files
#' @description This function will scan the subfolders of files/input folder for .fastq.gz or .bam files,
#' or the files/output folder for .bam files.
#' To generate .bam files from .fastq files, the input folders should be scanned using the type = "fastq" parameter.
#' Next, to conduct the analysis on .bam files that were generated in this step, use type = "bam".
#' Please refer to the tutorial for more details.
#' @param type Input data type in the files/input folder, use either 'fastq' or 'bam'. If QC processing was conducted using AlleleProfileR, use fastq-clean.
#' @return Sample table, listing the fastq or bam files for each sample.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.read.folders <- function(type = "fastq") {
  # read folders for files
  dirs <- list.dirs("files/input")[-1]
  subpos <- 13
  if (length(dirs) == 0) {
    stop("No suitable input folders can be found!")
  }

  output <- data.frame(Sample = substring(dirs,subpos),R1=NA,R2=NA,bam=NA)
  # read files in folders
  for (i in 1:length(dirs)) {
    if (type == "fastq") {
      temp <- list.files(dirs[i], pattern="*.fastq.gz", full.names=TRUE)
      if (length(temp) > 0) {
        if (length(temp) == 1) {
          output[i,c(2)] <- temp
        } else {
          output[i,c(2:3)] <- temp
        }

      } else {
        output[i,c(2:3)] <- NA
      }

    } else if (type == "fastq-clean") {
      temp <- list.files(dirs[i], pattern="*.clean.fastq.gz", full.names=TRUE)
      if (length(temp) > 0) {
        if (length(temp) == 1) {
          output[i,c(2)] <- temp
        } else {
          output[i,c(2:3)] <- temp
        }

      } else {
        output[i,c(2:3)] <- NA
      }

    } else if (type == "bam") {
      temp <- list.files(dirs[i], pattern="*.bam", full.names=TRUE)
      if (length(temp) > 0) {
        output[i,4] <- temp
      } else {
        output[i,4] <- NA
      }

    } else {
      stop("No suitable input data type!")
    }
  }

  return(output)
}

#' @title Wrapper execute function for the analysis
#' @description This is a background function that will process a single sample for a single gene region.
#' @param bamtable Data.frame containing the reads, as generated by AlleleProfileR.bam.
#' @param samplestable Samples table, inherited from config.
#' @param genestable Genes table, inherited from config.
#' @param i sample id
#' @param j gene id
#' @inheritParams AlleleProfileR.batch
#' @inheritParams AlleleProfileR.setup
#' @author Arne Bruyneel
#' @export
AlleleProfileR.execute <- function(bamtable, samplestable, genestable, i, j, cutoff, index,
                                   ignore.snp, ignore.single, summarize=TRUE, cut.range, cutoff.large,
                                   ignore.chimeric, chimeric.max.insertion.size, suppress.messages = F) {
  # for each gene we'll make a selections of reads that span the ROI within the GOI
  geneinfo <- genestable[j,]
  if (!suppress.messages) {
    cat("Currently processing gene: ", paste(geneinfo$Gene)," ... \n",sep="")
  }
  # process the selection
  selected_bam <- AlleleProfileR.getreads(bamtable, geneinfo$Chr, pcrrange = c(geneinfo$PCRStart, geneinfo$PCRStop),
                                          range = c(geneinfo$Start, geneinfo$Stop), purify = F)
  # purify is switched off in this command as we'll only clean once, for the BAM.
  # This does not need to be repeated for all genes within the BAM file.

  # init log
  logfile <- file(paste("files/output/",samplestable$Sample[i],"_",geneinfo$Gene,"_log.txt",sep=""), "w")

  if (dim(selected_bam)[1] > 0) {
    # reads were found in the BAM file
    # hence we will assess alleles
    if (!suppress.messages) {
      cat("Determining allele variants... \n")
    }
    variants <- AlleleProfileR.determine.variants(selected_bam, index, geneinfo, cutoff.large, ignore.snp,
                                                  cut.range, ignore.chimeric, chimeric.max.insertion.size,
                                                  suppress.messages)

    if (dim(variants)[1] > 0) {
      # make summaries
      if (!suppress.messages) {
        cat("Generating summary datasets and write results... \n")
      }
      write.csv(variants, row.names = F, file = paste("files/output/",samplestable$Sample[i],"_",geneinfo$Gene,"_all.csv",sep=""))
      cat("Success.", file=logfile)
      if (summarize) {
        alleles_plot <- AlleleProfileR.summary.profiled.alleles(variants, cutoff, ignore.single)
        write.csv(alleles_plot, row.names = F, file = paste("files/output/",samplestable$Sample[i],"_",geneinfo$Gene,"_plot.csv",sep=""))
      }
    } else {
      # Reads were detected, but the algorithm didn't determine any allele variants
      cat("Reads, but no variants detected.", file=logfile)
    }
  } else {
    # no reads were found in the BAM file, write to log
    cat("No reads detected.", file=logfile)
  }

  # close log file
  close(logfile)
}


#' @title Recompute summary output files
#' @description This function will recompute summary output files with defined cut-off value to exclude infrequent variants.
#' @param top Only report the top x variants
#' @inheritParams AlleleProfileR.batch
#' @inheritParams AlleleProfileR.setup
#' @return This function does not return anything. All results are written to .csv files in the output folder.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.batch.recompute <- function(config, cutoff = 0, ignore.single = F,
                                           top = 0, subset = NULL) {
  # determine the subset parameters
  # collect the data
  if (is.list(subset)) {
    if (length(subset) == 2) {
      soi <- subset[[1]]
      goi <- subset[[2]]

      samplestable <- config[[1]][soi,]
      genestable <- config[[2]][goi,]
    } else {
      stop("Illegal subset parameters")
    }

  } else {
    if (is.null(subset)) {
      samplestable <- config[[1]]
      genestable <- config[[2]]
    } else {
      stop("Illegal subset parameters")
    }
  }

  if (dim(samplestable)[1]*dim(genestable)[1] > 0) {

    # make table
    for (a in 1:dim(samplestable)[1]) {
      for (b in 1:dim(genestable)[1]) {
        ##
        tempfileall <- paste("files/output/",samplestable$Sample[a],"_",genestable$Gene[b],"_all.csv",sep="")
        tempfileplot <- paste("files/output/",samplestable$Sample[a],"_",genestable$Gene[b],"_plot.csv",sep="")

        if (file.exists(tempfileall)) {

          profiledvariants <- read.csv(tempfileall, header = T)
          tempalternate <- config[[8]][which(config[[1]][,1] == samplestable$Sample[a])]
          tempalternate <- tempalternate[[1]]
          tempalternate$gene <- as.character(tempalternate$gene)

          if (dim(profiledvariants)[1] > 0) {
            alleles_plot <- AlleleProfileR.summary.profiled.alleles(profiledvariants, cutoff, ignore.single, top,
                                                                    tempalternate$allele[which(tempalternate$gene == genestable$Gene[b])])
            write.csv(alleles_plot, row.names = F, file = tempfileplot)
          }

        }

      }
    }
  }
}

#' @title Determine the allelic variants for a sample and gene
#' @description This is the main worker function that parses through the reads in the bam file and determines their allele variants.
#' @param gene Gene information vector
#' @inheritParams AlleleProfileR.execute
#' @inheritParams AlleleProfileR.setup
#' @return Variants data.frame
#' @author Arne Bruyneel
#' @export
AlleleProfileR.determine.variants <- function(bamtable, index, gene, cutoff.large = 25,
                                              ignore.snp = F, cut.range = 0, ignore.chimeric = F,
                                              chimeric.max.insertion.size = 50, suppress.messages = F) {
  # param
  stopcodons <- c("TAG","TAA","TGA")
  checkcutrange <- FALSE
  cutsites <- NULL

  # extract gene info
  atgloc <- gene$ATG
  chr <- gene$Chr
  stoploc <- gene$StopCodon
  starttype <- gene$StartType
  stoptype <- gene$StopType
  # cut sites
  if (cut.range > 0 && !is.na(gene$CutSites)) {
    checkcutrange <- TRUE
    cutsites <- strsplit(paste(gene$CutSites), ";")[[1]]
    cutsites <- as.numeric(cutsites)
  }

  # segregate analysis by chimera and non-chimeras
  bam_chimera <- bamtable[which(bamtable$chimera == TRUE),]
  bam_nonchimera <- bamtable[which(bamtable$chimera == FALSE),]

  #############################################################################################
  ######## non-chimeras

  # these are not chimeric, but they may have a soft or hard clip
  if (dim(bam_nonchimera)[1] > 0) {
    # create output data frame
    output <- data.frame(name = bam_nonchimera$qname, cigar = bam_nonchimera$cigar, wt=F, snp=F, coding = F,
                         codinglength = 0, atg = F, fs = F, stop=F, pstop=F, sm = F, lg = F, chim=F, utr = F,
                         cryptic=F, error=F, gap=NA, allele = NA, unifiedseq=NA, unifiedpos=NA, unifiedcigar=NA,
                         indelseq = NA, cdsseq = NA, cryptic_start = NA, cryptic_stop = NA, qwidth=0, inrange=!checkcutrange)

    # generate progress bar
    if (!suppress.messages) {
      cat("Profiling non-chimeric reads...", sep="\n")
      pbnc <- txtProgressBar(min = 0, max = dim(output)[1], style = 3)
    }

    # loop through all non-chimeric reads
    for (f in 1:dim(output)[1]) {
      ## analyse the lead sequence using the function.
      temp_output <- AlleleProfileR.parseleadseq(bam_nonchimera[f,], gene, cutoff.large, index, list(checkcutrange,cut.range,cutsites))
      ## return(list(output_fs,output_sm,output_lg,dels,list(ins_loc,ins_bps),startpos+atgpos-1,indelseq,output_utr))

      output$inrange[f] <- temp_output[[10]]

      ### consider SNPs
      if (!ignore.snp) {
        output_snp <- snpsC(bam_nonchimera[f,], gene, index)
        tempsnps <- vector()
        tempsnpsaltbase <- vector()

        if (checkcutrange && output_snp$count > 0) {
          for (ts in 1:length(output_snp$snppos)) {
            if (iswithincutrangeC(cutsites, cut.range, as.integer(output_snp$snppos[ts]), 1, atgloc)) {
              output$inrange[f] <- output$inrange[f] || T
              tempsnps <- append(tempsnps, output_snp$snppos[ts])
              tempsnpsaltbase <- append(tempsnpsaltbase, output_snp$altbase[ts])
            }
          }

        } else {
          for (ts in 1:length(output_snp$snppos)) {
            tempsnps <- append(tempsnps, output_snp$snppos[ts])
            tempsnpsaltbase <- append(tempsnpsaltbase, output_snp$altbase[ts])
          }

        }

        if (length(tempsnps) == 0) {
          tempsnps <- c("")
          tempsnpsaltbase <- c("")
        }

        output_snp$snppos <- tempsnps
        output_snp$altbase <- tempsnpsaltbase

      } else {
        output_snp <- list(count=0, snppos = c(""), altbase = c(""))
      }

      ## assess coding frame
      temp_output_coding <- AlleleProfileR.parsecodingframe(bam_nonchimera[f,], gene, index, fs = temp_output[[1]])
      ## output: list(output_start,output_coding,output_fs,output_stop,output_pstop,length,output_wt,output_cryptic,seq)

      ## assign output data:::
      output$atg[f] <- temp_output_coding[[1]]
      output$coding[f] <- temp_output_coding[[2]]
      output$sm[f] <- temp_output[[2]]
      output$lg[f] <- temp_output[[3]]
      output$stop[f] <- temp_output_coding[[4]]
      output$pstop[f] <- temp_output_coding[[5]]
      output$wt[f] <- temp_output_coding[[7]]
      output$allele[f] <- variantnameC(temp_output[[4]],temp_output[[5]],output_snp)
      output$unifiedpos[f] <- bam_nonchimera$pos[f]
      output$indelseq[f] <- temp_output[[7]]
      output$utr[f] <- temp_output[[8]]
      output$fs[f] <- temp_output_coding[[3]]
      output$codinglength[f] <- temp_output_coding[[6]]
      output$cryptic[f] <- temp_output_coding[[8]]
      output$cdsseq[f] <- paste(temp_output_coding[[9]])
      output$snp[f] <- output_snp$count
      output$error[f] <- F
      output$cryptic_start[f] <- temp_output_coding[[10]]
      output$cryptic_stop[f] <- temp_output_coding[[11]]
      output$qwidth[f] <- paste(bam_nonchimera$qwidth[f])

      ## cut off S at start
      tempcigar <- cigarsubsC(bam_nonchimera[f,"cigar"])
      if (tempcigar[2] == "S") {
        # we'll cut off the start
        output$unifiedseq[f] <- substring(paste(bam_nonchimera$seq[f]),as.numeric(tempcigar[1])+1)
        output$unifiedcigar[f] <- generalpastelongC(tempcigar[3:(length(tempcigar))])

      } else {
        output$unifiedseq[f] <- paste(bam_nonchimera$seq[f])
        output$unifiedcigar[f] <- paste(bam_nonchimera$cigar[f])

      }

      ## update progress
      if (!suppress.messages) {
        setTxtProgressBar(pbnc, f)
      }
    }

    if (!suppress.messages) {
      close(pbnc)
    }

  } else {
    output <- as.data.frame(matrix(0,nrow=0,ncol=25)) # null output
  }

  #############################################################################################
  ######## chimeras

  # these are not chimeric, but they may have a soft or hard clip
  if ((dim(bam_chimera)[1] > 0) && !ignore.chimeric) {
    # create output data frame
    outputchim <- data.frame(name = unique(bam_chimera$qname),cigar = NA, wt=F, snp =F, coding = F,
                             codinglength = 0, atg = F, fs = F, stop=F, pstop=F, sm = F, lg = F, chim=T,
                             utr = F, cryptic=F, error=F, gap=NA, allele = NA, unifiedseq=NA, unifiedpos=NA,
                             unifiedcigar=NA, indelseq = NA, cdsseq = NA, cryptic_start = NA, cryptic_stop = NA,
                             qwidth=0, inrange=!checkcutrange)

    # generate progress bar
    if (!suppress.messages) {
      cat("Profiling chimeric reads...", sep="\n")
      pbnd <- txtProgressBar(min = 0, max = dim(outputchim)[1], style = 3)
    }

    for (g in 1:dim(outputchim)[1]) {
      ## get info associated with the qname
      bam_temp <- bam_chimera[bam_chimera$qname == outputchim$name[g],]

      ## no of seq entries?
      noseq <- dim(bam_temp)[1] # typically there are two seqs, for example if there is a large gap as a result of using two guides.
      ## one upper and one lower?
      pairup <- (dim(bam_temp[which(bam_temp$lower == T),])[1] == 1) && (dim(bam_temp[which(bam_temp$upper == T),])[1] == 1)

      if ((noseq == 2) && (pairup)) {
        # hence there are two sequences in the chimera: one at the lower end and one at the upper end of the range of interest
        # the AlleleProfileR.binreads function assigns reads with boolean logic for whether they span the start of the region of interest or the end.
        # ie, the first aligned base pairs.

        # for human interest:
        outputchim$cigar[g] <- c(paste(bam_temp$cigar[bam_temp$lower ==T],"-",bam_temp$cigar[bam_temp$upper ==T]))

        # the left sequence contains the ATG, ie the assumptions is that the first alignment base pairs are located just before the ATG
        # and can hence be analysed using the standard algorithm for lead sequences
        temp_output_lead <- AlleleProfileR.parseleadseq(bam_temp[bam_temp$lower ==T,], gene, cutoff.large, index, list(checkcutrange,cut.range,cutsites))

        # where does the left/lead sequence end (and hence a potential gap start?)
        # so what is the position of the last bp?
        lead_startpos <- bam_temp$pos[bam_temp$lower ==T]
        lead_cigarsubs <- cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"])
        lead_endpos <- bam_temp$posend[bam_temp$lower ==T] # with respect to the start of the lead alignment.

        ###############################################
        ###### analyse the gap and account for potential overlap of the reads.

        # size of gap
        outputchim$gap[g] <- bam_temp$pos[bam_temp$upper ==T]-lead_endpos-1

        if (outputchim$gap[g] < 0) {
          outputchim$error[g] <- T
          # report as failure

        } else {
          # prime for insertion
          overlap <- 0
          insertiongapbool <- F
          insertedseqgap <- ""

          # initialize
          gap_seq <- NA

          # determine the number of bases that maximally can be aligned
          nobasesavailable <- max(bam_temp$qwidth[bam_temp$lower ==T], bam_temp$qwidth[bam_temp$upper ==T])
          outputchim$qwidth[g] <- nobasesavailable
          # the sum of H and S in the two reads needs to be equal to the number of bases, or else there is no gurantee that none were used double
          trimleft <- TRUE # trim left is default

          # check whether there is a replication of the first and last couple of base pairs.
          if (tail(cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"]), n=1) == "H" & (cigarsubsC(bam_temp[bam_temp$upper ==T,"cigar"]))[2] == "S") {
            # define some stuff
            left_seq <- bam_temp$seq[bam_temp$lower ==T]
            left_qwidth <- bam_temp$qwidth[bam_temp$lower ==T]
            left_h <- as.numeric(tail(cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"]), n=2)[1])
            right_seq <- bam_temp$seq[bam_temp$upper ==T]
            right_qwidth <- bam_temp$qwidth[bam_temp$upper ==T]
            right_s <- as.numeric(cigarsubsC(bam_temp[bam_temp$upper ==T,"cigar"])[1]) # the number of bases with 'S' indentier

            # test whether bases have been used multiple times:
            if (left_h+right_s < nobasesavailable) {
              # one or more bases were used multiple times:
              overlap <- nobasesavailable - (left_h+right_s)

              # should the duplication be trimmed of the match of the left or right sequence?
              if (left_h < nobasesavailable - right_s) {
                ## trim from right
                trimleft <- FALSE

              } else {
                ## trim from left
                trimleft <- TRUE

              }

            } else if (left_h+right_s > nobasesavailable) {
              # check whether there is an insertion at the gap site.
              # the insertion will be part of the S region
              possible_insertion <- c(0)
              insertion_match_size <- c(10) # the sliding window that will be used
              insertion_limit <- min(chimeric.max.insertion.size,right_s)
              for (insertiongap in 1:insertion_limit) {
                if (substring(left_seq, left_qwidth-insertion_match_size) == substring(right_seq, right_s-insertiongap-insertion_match_size, right_s-insertiongap)) {
                  possible_insertion <- append(possible_insertion,insertiongap)
                }
              }
              # inserted sequence:
              insertionselected <- max(possible_insertion)
              if (insertionselected > 0) {
                insertiongapbool <- T
                insertedseqgap <- substring(right_seq, right_s-insertionselected+1, right_s)
              }
            }

            # gap length
            outputchim$gap[g] <- outputchim$gap[g] + overlap

          } else if (tail(cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"]), n=1) == "S" & (cigarsubsC(bam_temp[bam_temp$upper ==T,"cigar"]))[2] == "H") {
            # define some stuff
            left_seq <- bam_temp$seq[bam_temp$lower ==T]
            left_qwidth <- bam_temp$qwidth[bam_temp$lower ==T]
            left_s <- as.numeric(tail(cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"]), n=2)[1])
            right_seq <- bam_temp$seq[bam_temp$upper ==T]
            right_qwidth <- bam_temp$qwidth[bam_temp$upper ==T]
            right_h <- as.numeric(cigarsubsC(bam_temp[bam_temp$upper ==T,"cigar"])[1])

            # test whether bases have been used multiple times:
            if (left_s+right_h < nobasesavailable) {
              # one or more bases were used multiple times:
              overlap <- nobasesavailable - (left_s+right_h)

              # should the duplication be trimmed of the match of the left or right sequence?
              if (left_s < nobasesavailable - right_h) {
                ## trim from right
                trimleft <- FALSE

              } else {
                ## trim from left
                trimleft <- TRUE
              }

            } else if (left_s+right_h > nobasesavailable) {
              # check whether there is an insertion at the gap site.
              # the insertion will be part of the S region
              possible_insertion <- c(0)
              insertion_match_size <- c(10) # the sliding window that will be used
              insertion_limit <- min(chimeric.max.insertion.size,left_s)
              for (insertiongap in 1:insertion_limit) {
                if (substring(left_seq, left_qwidth-left_s+1+insertiongap, left_qwidth-left_s+insertiongap+insertion_match_size) == substring(right_seq, 1, insertion_match_size)) {
                  possible_insertion <- append(possible_insertion,insertiongap)
                }
              }
              # inserted sequence:
              insertionselected <- max(possible_insertion)
              if (insertionselected > 0) {
                insertiongapbool <- T
                insertedseqgap <- substring(left_seq, left_qwidth-left_s+1, left_qwidth-left_s+insertionselected)
              }
            }

            outputchim$gap[g] <- outputchim$gap[g] + overlap
            # this formula doesn't correct for nomenclature though, only the de facto length of the gap.

          } else {
            # current version of the algorithm does not know what to do for now
            outputchim$error[g] <- T
          }
        }

      } else { # with respect to two seq in the chimeric read
        # current version of the algorithm does not know what to do for now
        outputchim$error[g] <- T
      }

      # hence current version of the algorithm should be able to manage with the read
      if (!outputchim$error[g]) {
        #
        ########################################################################################
        ########### deal with allele name
        if (!is.na(outputchim$gap[g])) {
          # ATG position
          atgpos <- temp_output_lead[[6]]

          ######
          # check whether if the del is shifted you can get the same mutant genotype:
          ######
          # method of implementation, extract the deleted sequence and the leading and trailing 25 bps (as defined in ref_width)
          ref_width <- 25
          # then delete the deleted sequence and derive the mutant sequence
          # then shift the deleted frame both up and downstream for 20 bps (shifts) in 1 bp steps and delete that frame,
          # can the identical resulting seq be generated using one of those shifts?

          # in a frame were the first base is counted as '1', bases 1 to ref_width will be the upstream trailing end,
          # and n-ref_width+1 to n the downstream trailing end.
          frame_seq <- getreferenceC(index, chr, lower=lead_endpos-ref_width+1, upper=lead_endpos+outputchim$gap[g]+ref_width)
          mutant_frame <- paste(getreferenceC(index, chr, lower=lead_endpos-ref_width+1, upper=lead_endpos), getreferenceC(index, chr, lower=lead_endpos+outputchim$gap[g]+1, upper=lead_endpos+outputchim$gap[g]+ref_width),sep="")

          # shift this frame
          # don't use the referene file for this as this is computationally too intense, use substring here on frame_crisprseq.
          shifts <- c(-20:20)
          successful_shifts <- NA
          final_shift <- 0

          for (shift in shifts) {
            mutant_frame_shifted <- paste(substring(frame_seq,1,ref_width+shift),substring(frame_seq,nchar(frame_seq)-ref_width+shift+1,nchar(frame_seq)),sep="")
            if (mutant_frame_shifted == mutant_frame) {
              if (is.na(successful_shifts[1])) {
                successful_shifts <- shift
              } else {
                successful_shifts <- append(successful_shifts,shift)
              }
            }
          }

          # sanity check
          if (!(0 %in% successful_shifts)) {
            cat("\n",paste(outputchim$name[g],outputchim$gap[g],insertiongapbool))
            stop("Fatal failure: No shift was not observed in sucessful shifts.")


          } else {
            ###

            # so basically there are multiple ways in which we can get the same mutation, for nomenclature purposes will chose the frame with the
            # most negative shift, and the largest shift. Hence
            final_shift <- min(successful_shifts)

            # this equation will result in a zero value if no other is found.
            # the final shift value will used as well to generate the left and right net sequences

            # parsing of end sequence
            # the relative shift should be handed over here such that the shift can be accounted for
            temp_output_trail <- AlleleProfileR.parsetrailseq(bam_temp[bam_temp$upper ==T,], gene, cutoff.large, index, input_atg = temp_output_lead[[9]], list(checkcutrange,cut.range,cutsites))

            # get a unified allele name, irrespective of the overlap
            if (outputchim$gap[g] == 1) {
              merged_dels <- list(T, c(temp_output_lead[[4]][[2]],paste(checknegC(lead_endpos-atgpos+2+final_shift),sep=""),temp_output_trail[[4]][[2]]))

            } else {
              merged_dels <- list(T, c(temp_output_lead[[4]][[2]],paste(checknegC(lead_endpos-atgpos+2+final_shift),"_",checknegC(lead_endpos-atgpos+outputchim$gap[g]+final_shift+1),sep=""),temp_output_trail[[4]][[2]]))
            }


            if (insertiongapbool) {
              merged_ins <- list(T,c(temp_output_lead[[5]][[2]],c(paste(checknegC(lead_endpos-atgpos+2+final_shift),"_",checknegC(lead_endpos-atgpos+1+outputchim$gap[g]+final_shift),sep="")),temp_output_trail[[5]][[2]]),c(temp_output_lead[[5]][[3]],c(insertedseqgap),temp_output_trail[[5]][[3]]))
            } else {
              merged_ins <- list(T, c(temp_output_lead[[5]][[2]],temp_output_trail[[5]][[2]]),c(temp_output_lead[[5]][[3]],temp_output_trail[[5]][[3]]))
            }

            # gap seq
            gap_seq <- getreferenceC(index,chr,lower=lead_endpos+final_shift+1,upper=lead_endpos+outputchim$gap[g]+final_shift)

            ## is the gap in the utr?
            test_gap_utr <- !mathintersectC(atgloc, stoploc+2, lead_endpos+final_shift, lead_endpos+outputchim$gap[g]+final_shift)

            if (test_gap_utr) {
              outputchim$sm[g] <- temp_output_lead[[2]] | temp_output_trail[[2]] | (outputchim$gap[g] <= cutoff.large)
              outputchim$lg[g] <- temp_output_lead[[3]] | temp_output_trail[[3]] | (outputchim$gap[g] > cutoff.large)
              outputchim$utr[g] <- T
              gap_utr <- T

            } else {
              outputchim$sm[g] <- temp_output_lead[[2]] | temp_output_trail[[2]] | (outputchim$gap[g] <= cutoff.large)
              outputchim$lg[g] <- temp_output_lead[[3]] | temp_output_trail[[3]] | (outputchim$gap[g] > cutoff.large)
              outputchim$utr[g] <- temp_output_lead[[8]] | temp_output_trail[[7]]
              gap_utr <- F

            }

            outputchim$inrange[g] <- temp_output_lead[[10]] | temp_output_trail[[8]]

            if (outputchim$gap[g] > 0) {
              ## is the gap in the cut range?
              if (checkcutrange) {
                test_gap_cutrange <- iswithincutrangeC(cutsites, cut.range, lead_endpos+final_shift-atgloc+1, outputchim$gap[g], atgloc)

                if (test_gap_cutrange) {
                  outputchim$inrange[g] <- outputchim$inrange[g] || T
                }
              }

            }


          }



        } else {

          # parsing of end sequence
          # the relative shift should be handed over here such that the shift can be accounted for
          temp_output_trail <- AlleleProfileR.parsetrailseq(bam_temp[bam_temp$upper ==T,], gene, cutoff.large, index, input_atg = temp_output_lead[[9]], list(checkcutrange,cut.range,cutsites))

          merged_dels <- list(temp_output_lead[[4]][[1]]|temp_output_trail[[4]][[1]], c(temp_output_lead[[4]][[2]],temp_output_trail[[4]][[2]]))
          merged_ins <- list(temp_output_lead[[5]][[1]]|temp_output_trail[[5]][[1]], c(temp_output_lead[[5]][[2]],temp_output_trail[[5]][[2]]), c(temp_output_lead[[5]][[3]],temp_output_trail[[5]][[3]]))

          outputchim$sm[g] <- temp_output_lead[[2]] | temp_output_trail[[2]]
          outputchim$lg[g] <- temp_output_lead[[3]] | temp_output_trail[[3]]
          outputchim$utr[g] <- temp_output_lead[[8]] | temp_output_trail[[7]]
          outputchim$inrange[g] <- temp_output_lead[[10]] | temp_output_trail[[8]]

          ##
          final_shift <- 0
          gap_utr <- F
        }


        ########################################################################################
        ########### deal with unified information
        left_subs <- cigarsubsC(bam_temp[bam_temp$lower ==T,"cigar"])
        right_subs <- cigarsubsC(bam_temp[bam_temp$upper ==T,"cigar"])

        left_cigar <- bam_temp$cigar[bam_temp$lower ==T]
        right_cigar <- bam_temp$cigar[bam_temp$upper ==T]
        left_seq <- bam_temp$seq[bam_temp$lower ==T]
        right_seq <- bam_temp$seq[bam_temp$upper ==T]


        # preprocess the left sequence
        # does it start with a S?
        if (left_subs[2] == "S") {
          left_cigar <- substring(paste(left_cigar),3)
          left_seq <- substring(paste(left_seq),as.numeric(left_subs[1])+1)
          left_subs <- left_subs[3:length(left_subs)]
        } else if (left_subs[2] == "H") {
          left_cigar <- substring(paste(left_cigar),3)
          left_subs <- left_subs[3:length(left_subs)]
        }

        # preprocess the right sequence
        if (tail(right_subs, n=1) == "S") {
          right_subs <- right_subs[1:(length(right_subs)-2)]
          right_seq <- substring(paste(right_seq),1,nchar(right_seq)-as.numeric(right_subs[length(right_subs)-1]))
        } else if (tail(right_subs, n=1) == "H") {
          right_subs <- right_subs[1:(length(right_subs)-2)]
        }

        ## precess the tail of the left and the start of the right, these will have to be merged
        if (tail(left_subs, n=1) == "H") {
          if (final_shift == 0) {
            left_cigar <- generalpastelongC(left_subs[1:(length(left_subs)-2)])

          } else {
            if (length(left_subs) == 4) {
              left_cigar <- paste(as.numeric(left_subs[1])+final_shift,left_subs[2],sep="")
            } else {
              left_cigar <- paste(generalpastelongC(left_subs[1:(length(left_subs)-4)]),as.numeric(left_subs[(length(left_subs)-3)])+final_shift,left_subs[(length(left_subs)-2)],sep="")
            }
          }

          if (trimleft) {
            left_seq <- substring(bam_temp$seq[bam_temp$lower ==T],1,sum(as.numeric(left_subs[mathrangeC(1,length(left_subs)-2,2)]))-sum(cigarsubsdeletionsC(left_subs, end = length(left_subs)))-overlap)
          } else {
            left_seq <- substring(bam_temp$seq[bam_temp$lower ==T],1,sum(as.numeric(left_subs[mathrangeC(1,length(left_subs)-2,2)]))-sum(cigarsubsdeletionsC(left_subs, end = length(left_subs))))
          }


        } else if (tail(left_subs, n=1) == "S") {
          if (final_shift == 0) {
              left_cigar <- generalpastelongC(left_subs[1:(length(left_subs)-2)])

          } else {
            if (length(left_subs) == 4) {
              left_cigar <- paste(as.numeric(left_subs[1])+final_shift,left_subs[2],sep="")
            } else {
              left_cigar <- paste(generalpastelongC(left_subs[1:(length(left_subs)-4)]),as.numeric(left_subs[(length(left_subs)-3)])+final_shift,left_subs[(length(left_subs)-2)],sep="")
            }

          }

          if (trimleft) {
            left_seq <- substring(bam_temp$seq[bam_temp$lower ==T],1,sum(as.numeric(left_subs[mathrangeC(1,length(left_subs)-2,2)]))-sum(cigarsubsdeletionsC(left_subs, end = length(left_subs)))-overlap)
          } else {
            left_seq <- substring(bam_temp$seq[bam_temp$lower ==T],1,sum(as.numeric(left_subs[mathrangeC(1,length(left_subs)-2,2)]))-sum(cigarsubsdeletionsC(left_subs, end = length(left_subs))))
          }

        }

        # note: overlap in seq is dealt with in the left seq.
        if (right_subs[2] == "H") {
          if (final_shift == 0 && overlap == 0) {
            right_cigar <- generalpastelongC(right_subs[3:length(right_subs)])

          } else {
            if (length(right_subs) == 4) {
              right_cigar <- paste(as.numeric(right_subs[3])-final_shift-overlap,right_subs[4],sep="")
            } else {
              right_cigar <- paste(as.numeric(right_subs[3])-final_shift-overlap,right_subs[4],generalpastelongC(right_subs[5:length(right_subs)]),sep="")
            }
          }

          if (!trimleft) {
            right_seq <- substring(bam_temp$seq[bam_temp$upper ==T], 1+overlap)
          }

        } else if (right_subs[2] == "S") {
          if (final_shift == 0  && overlap == 0) {
            right_cigar <- generalpastelongC(right_subs[3:length(right_subs)])

          } else {
            if (length(right_subs) == 4) {
              right_cigar <- paste(as.numeric(right_subs[3])-final_shift-overlap,right_subs[4],sep="")
            } else {
              right_cigar <- paste(as.numeric(right_subs[3])-final_shift-overlap,right_subs[4],generalpastelongC(right_subs[5:length(right_subs)]),sep="")
            }
          }

          if (trimleft) {
            right_seq <- substring(bam_temp$seq[bam_temp$upper ==T], as.numeric(right_subs[1])+1)
          } else {
            right_seq <- substring(bam_temp$seq[bam_temp$upper ==T], as.numeric(right_subs[1])+1+overlap)
          }
        }

        # unified seq, pos, and cigar

        if (insertiongapbool) {
          outputchim$unifiedseq[g] <- paste(left_seq,insertedseqgap,right_seq,sep="") # the default for insertedseqgap is ""
          outputchim$unifiedcigar[g] <- paste(left_cigar,outputchim$gap[g],"D",nchar(insertedseqgap),"I",right_cigar,sep="")
        } else {
          outputchim$unifiedseq[g] <- paste(left_seq,right_seq,sep="")
          outputchim$unifiedcigar[g] <- paste(left_cigar,outputchim$gap[g],"D",right_cigar,sep="")
        }

        outputchim$unifiedpos[g] <- lead_startpos

        # extract gap sequence too
        outputchim$indelseq[g] <- paste(temp_output_lead[[7]],"_._",gap_seq,"_._",temp_output_trail[[6]],sep="")

        # frame shift:
        # if the gap length is not a multiple of three
        if ((((nchar(paste(gap_seq))-nchar(insertedseqgap)) %% 3) != 0) & gap_utr == F) {
          gap_fs <- T
        } else {
          gap_fs <- F
        }

        ########################################################################################
        ########### assess coding frame

        ## gather data of both reads into a dummy object
        dummyobj <- data.frame(pos = lead_startpos, seq = outputchim$unifiedseq[g], cigar = outputchim$unifiedcigar[g], posend = NA, qname = bam_temp$qname[bam_temp$upper ==T])
        dummyobj$posend <- readposendC(dummyobj)
        dummyobj$cigar <- as.character(dummyobj$cigar)
        dummyobj$seq <- as.character(dummyobj$seq)

        ## sanity check
        finalsanitycheck <- mergedSanityCheckC(dummyobj)

        if (finalsanitycheck) {
          ## execute parsecodingframe function
          temp_output_coding_chim <- AlleleProfileR.parsecodingframe(dummyobj, gene, index, fs = c(temp_output_lead[[1]] | temp_output_trail[[1]] | gap_fs))
          ## output: list(output_start,output_coding,output_fs,output_stop,output_pstop,length,output_wt,output_cryptic,seq,output_snp)

          ########################################################################################
          ### consider SNPs
          if (!ignore.snp) {
            output_snp <- snpsC(dummyobj, gene, index)
            tempsnps <- vector()
            tempsnpsaltbase <- vector()

            if (checkcutrange && output_snp$count > 0) {
              for (ts in 1:length(output_snp$snppos)) {
                if (iswithincutrangeC(cutsites, cut.range, as.integer(output_snp$snppos[ts]), 1, atgloc)) {
                  outputchim$inrange[g] <- outputchim$inrange[g] || T
                  tempsnps <- append(tempsnps, output_snp$snppos[ts])
                  tempsnpsaltbase <- append(tempsnpsaltbase, output_snp$altbase[ts])
                }
              }

            } else {
              for (ts in 1:length(output_snp$snppos)) {
                tempsnps <- append(tempsnps, output_snp$snppos[ts])
                tempsnpsaltbase <- append(tempsnpsaltbase, output_snp$altbase[ts])
              }

            }

            if (length(tempsnps) == 0) {
              tempsnps <- c("")
              tempsnpsaltbase <- c("")
            }

            output_snp$snppos <- tempsnps
            output_snp$altbase <- tempsnpsaltbase

          } else {
            output_snp <- list(count=0, snppos = c(""), altbase = c(""))
          }

          ########################################################################################
          ########### write outputs

          outputchim$allele[g] <- variantnameC(merged_dels, merged_ins, output_snp)
          outputchim$fs[g] <- temp_output_coding_chim[[3]]
          outputchim$coding[g] <- temp_output_coding_chim[[2]]
          outputchim$codinglength[g] <- temp_output_coding_chim[[6]]
          outputchim$atg[g] <- temp_output_coding_chim[[1]]
          outputchim$pstop[g] <- temp_output_coding_chim[[5]]
          outputchim$stop[g] <- temp_output_coding_chim[[4]]
          outputchim$wt[g] <- temp_output_coding_chim[[7]]
          outputchim$cryptic[g] <- temp_output_coding_chim[[8]]
          outputchim$cdsseq[g] <- paste(temp_output_coding_chim[[9]])
          outputchim$snp[g] <- output_snp$count
          outputchim$cryptic_start[g] <- temp_output_coding_chim[[10]]
          outputchim$cryptic_stop[g] <- temp_output_coding_chim[[11]]

        } else {
          #
          outputchim$error[g] <- T
          outputchim$allele[g] <- "Other"
          outputchim$wt[g] <- F
        } # end with respect to sanity check

      } else {
        #
        outputchim$allele[g] <- "Other"
        outputchim$wt[g] <- F
      } # end with respect to no error

      if (!suppress.messages) {
        ## update progress
        setTxtProgressBar(pbnd, g)
      }
    }

    if (!suppress.messages) {
      close(pbnd)
    }

  } else {
    outputchim <- as.data.frame(matrix(0,nrow=0,ncol=25))
  }

  ## merged output for both chimeric and non-chimeric reads
  return(rbind(output,outputchim))
}

#' @title Parse the lead sequence in a chimeric pair
#' @description This function processes the leading sequence in a chimeric pair.
#' @param obj Row in the BAM datatable, a sequencing read.
#' @param cutrangelist cutrangelist
#' @inheritParams AlleleProfileR.determine.variants
#' @inheritParams AlleleProfileR.execute
#' @inheritParams AlleleProfileR.setup
#' @return List with elements: output_fs, output_sm, output_lg, dels, list(ins_loc,ins_bps), startpos+atgpos-1, indelseq, output_utr, output_atg, output_inrange
#' @author Arne Bruyneel
#' @export
AlleleProfileR.parseleadseq <- function(obj, gene, cutoff.large, index, cutrangelist) {

  atgloc <- gene$ATG
  stoploc <- gene$StopCodon
  chr <- gene$Chr

  # list(checkcutrange,cut.range,cutsites)
  checkcutrange <- cutrangelist[[1]]
  cut.range <- cutrangelist[[2]]
  cutsites <- cutrangelist[[3]]

  ###############################################
  ###### prepare output variables

  output_atg <- F # TRUE if ATG destroyed
  output_lg <- F # TRUE if large deletion
  output_sm <- F # TRUE if small deletion
  output_pstop <- F # TRUE if premature stop introduced
  output_stop <- F # TRUE if actual stop is destroyed
  output_utr <- F # TRUE if indel in untranslated region
  output_inrange <- !checkcutrange
  bool_dels <- F
  dels <- c("")
  bool_ins <- F
  ins_loc <- c("")
  ins_bps <- c("")
  indelseq <- c("")
  output_fs <- F

  # start position
  startpos <- obj$pos

  # stop codons
  stopcodons <- c("TAG","TAA","TGA")

  ###############################################
  ###### cigar string

  # go through the cigar string
  cigarsubs <- cigarsubsC(obj$cigar)

  # check whether there is some clipping at the start
  if (cigarsubs[2] == "H") {
    cigarsubs_woH <- cigarsubs[3:length(cigarsubs)]
    parsed_seq <- obj$seq
  } else if (cigarsubs[2] == "S") {
    cigarsubs_woH <- cigarsubs[3:length(cigarsubs)]
    shift <- as.numeric(cigarsubs[1])
    parsed_seq <- substring(obj$seq,as.numeric(cigarsubs[1])+1)
  } else {
    cigarsubs_woH <- cigarsubs
    parsed_seq <- obj$seq
  }

  ###############################################
  ###### Does the cigar cigarsubs reveal any inserts or deletions

  if (length(cigarsubs) == 2 & cigarsubs[2] == "M") {
    # so basically there are only matches.
    # the sequence spans the whole region of interest because it was selected using the span.range function

    atgcheck <- checkatgC(obj, gene)
    atgpos <- atgcheck[2]

  } else {
    # there are some indels...

    ###############################################
    ### is the ATG sequence destroyed

    atgcheck <- checkatgC(obj, gene)
    output_atg <- atgcheck[1]
    atgpos <- atgcheck[2]
    atgfound <- atgcheck[3]

    ###############################################
    ### is the stop sequence destroyed

    stopcheck <- checkstopC(obj, gene)
    output_stop <- stopcheck[1]
    stoppos <- stopcheck[2]
    stopfound <- stopcheck[3]

    ###############################################
    ###  small or large deletions/insertions -- frame shift mutation

    #in this case positions post the start are of interest.

    temp <- c(gsubfn::strapplyc(paste(obj$cigar), "([[:digit:]]+)D")[[1]], gsubfn::strapplyc(paste(obj$cigar), "([[:digit:]]+)I")[[1]])
    if (length(temp) > 0) {
      # so there is at least one deletion
      # where is it located with respect to the ATG location
      for (d in 4:length(cigarsubs_woH)) {
        if ((cigarsubs_woH[d] == "D") | (cigarsubs_woH[d] == "I")) {
          # need to substract the insertions here, because the startposition is with respect to the reference sequence
          posstart <- (startpos-1+sum(as.numeric(cigarsubs_woH[mathrangeC(1,d-2,2)]))+1-sum(cigarsubsinsertionsC(cigarsubs_woH, d-2, 0, type = "cigar")))-atgloc
          length <- as.numeric(cigarsubs_woH[d-1])

          if (cigarsubs_woH[d] == "D") {
            test_utr <- iswithincdsC(atgcheck[[3]], stopcheck[[3]], posstart, length, obj$pos, atgloc, stoploc)
            if (checkcutrange) {
              test_range <- iswithincutrangeC(cutsites, cut.range, posstart, length, atgloc)
            }

          } else {
            test_utr <- iswithincdsC(atgcheck[[3]], stopcheck[[3]], posstart, 1, obj$pos, atgloc, stoploc)
            if (checkcutrange) {
              test_range <- iswithincutrangeC(cutsites, cut.range, posstart, 1, atgloc)
            }

          }

          if (test_utr) {
            # mutation is in coding sequence so we need to consider frame shifts
            # frame shift is a deletion or insert distinct from a multiple of three (ie del length mod 3 != 0)
            if ((length %% 3) != 0) {
              if (output_atg == F) {
                output_fs <- T
              }
            }

            # size matters if in frame, especially if not frame shift
            if (length > cutoff.large) {
              output_lg <- T
            } else {
              output_sm <- T
            }

          } else {
            # mutation is in UTR
            output_utr <- T
          }

          # cut site positioning NHEJ
          # this is global variable for all variants in this reads analysis, will be TRUE if at least one I/D is in range
          if (checkcutrange) {
            if (test_range) {
              # in range, hence OR TRUE
              output_inrange <- output_inrange || T
            }
          }

          # deal with naming of the variant
          # here the positions are stored, the actual naming is done later
          if ((checkcutrange && test_range) || !checkcutrange) {
            #
            if (cigarsubs_woH[d] == "D") {
              bool_dels <- T
              ## naming
              if (dels[1] == "") {
                if (length == 1) {
                  dels <- paste(checknegC(posstart+1),sep="")
                } else {
                  dels <- paste(checknegC(posstart+1),"_",checknegC(posstart+length),sep="")
                }
              } else {
                if (length == 1) {
                  dels <- append(dels,paste(checknegC(posstart+1),sep=""))
                } else {
                  dels <- append(dels,paste(checknegC(posstart+1),"_",checknegC(posstart+length),sep=""))
                }
              }

              ## seq of deletion
              temp_indelseq <- getreferenceC(index,chr,lower=atgloc+posstart,upper=atgloc+posstart+length-1)

            } else if (cigarsubs_woH[d] == "I") {
              ## inserted bases
              bool_ins <- T
              ins_temp <- seqinsertedC(paste(parsed_seq), cigarsubs_woH, d)

              ## naming
              if (ins_loc[1] == "") {
                ins_loc <- paste(checknegC(posstart),"_",checknegC(posstart+1),sep="")
                ins_bps <- ins_temp
              } else {
                ins_loc <- append(ins_loc,paste(checknegC(posstart),"_",checknegC(posstart+1),sep=""))
                ins_bps <- append(ins_bps,ins_temp)
              }

              ## seq of insertion
              temp_indelseq <- ins_temp

            }

            if (indelseq == "") {
              indelseq <- temp_indelseq
            } else {
              indelseq <- paste(indelseq,"_",temp_indelseq,sep="")
            }

          }

        }
      }
    }

  } # close if with respect to matches only

  ###############################################
  ### return
  return(list(output_fs, output_sm, output_lg, list(bool_dels, dels), list(bool_ins, ins_loc, ins_bps), startpos+atgpos-1, indelseq, output_utr, output_atg, output_inrange))
}

#' @title Parse the trailing sequence in a chimeric pair
#' @description Worker function to process the trailing sequence of a chimeric pair.
#' @inheritParams AlleleProfileR.parseleadseq
#' @param input_atg If TRUE, ATG is destroyed in the lead sequence
#' @return List with elements: output_fs, output_sm, output_lg, dels, list(ins_loc,ins_bps), indelseq, output_utr, output_inrange
#' @author Arne Bruyneel
#' @export
AlleleProfileR.parsetrailseq <- function(obj, gene, cutoff.large, index, input_atg, cutrangelist) {
  # extract gene info
  atgloc <- gene$ATG
  stoploc <- gene$StopCodon
  chr <- gene$Chr

  # list(checkcutrange,cut.range,cutsites)
  checkcutrange <- cutrangelist[[1]]
  cut.range <- cutrangelist[[2]]
  cutsites <- cutrangelist[[3]]

  # go through the cigar string
  cigarsubs <- cigarsubsC(obj$cigar)
  if (cigarsubs[2] == "H") {
    cigarsubs_woH <- cigarsubs[3:length(cigarsubs)]
    shift <- 0
    parsed_seq <- obj$seq
  } else if (cigarsubs[2] == "S") {
    cigarsubs_woH <- cigarsubs[3:length(cigarsubs)]
    shift <- as.numeric(cigarsubs[1])
    parsed_seq <- substring(obj$seq,as.numeric(cigarsubs[1])+1)
  } else {
    cigarsubs_woH <- cigarsubs
    parsed_seq <- obj$seq
  }

  ###############################################
  ###### start position

  atgcheck <- checkatgC(obj, gene)
  stopcheck <- checkstopC(obj, gene)
  stoppos <- stopcheck[2]

  relstart <- obj$pos - atgloc

  ###############################################
  ###### prepare output variables
  output_lg <- F
  output_sm <- F
  output_pstop <- F
  output_utr <- F # TRUE if indel in untranslated region
  output_inrange <- !checkcutrange
  bool_dels <- F
  dels <- c("")
  bool_ins <- F
  ins_loc <- c("")
  ins_bps <- c("")
  indelseq <- c("")
  output_fs <- F

  ###############################################
  ###### Does the cigar cigarsubs reveal any inserts or deletions

  if (length(cigarsubs) == 2 & cigarsubs[2] == "M") {
    # so basically there are only matches.
    # the sequence spans the whole region of interest because it was selected using the span.range function

    output_wt <- T
  }
  # there are additional mechanisms in which the read could be a WT, indeed there maybe a soft or hard clip before or after, which is in fact sequencing noise?

  ###############################################
  ###  small or large deletions/insertions -- frame shift mutation

  #in this case positions post the start are of interest.
  temp <- c(gsubfn::strapplyc(paste(obj$cigar), "([[:digit:]]+)D")[[1]],gsubfn::strapplyc(paste(obj$cigar), "([[:digit:]]+)I")[[1]])
  if (length(temp) > 0) {
    # so there is at least one deletion
    # where is it located with respect to the ATG location
    for (d in 4:length(cigarsubs_woH)) {
      if ((cigarsubs_woH[d] == "D") | (cigarsubs_woH[d] == "I")) {
        #
        posstart <- sum(as.numeric(cigarsubs_woH[mathrangeC(1,d-2,2)]))+1-sum(cigarsubsinsertionsC(cigarsubs, d-2, 0, type = "cigar"))
        length <- as.numeric(cigarsubs_woH[d-1])

        if (cigarsubs_woH[d] == "D") {
          test_utr <- iswithincdsC(atgcheck[[3]], stopcheck[[3]], relstart+posstart, length, obj$pos, atgloc, stoploc)
          if (checkcutrange) {
            test_range <- iswithincutrangeC(cutsites, cut.range, relstart+posstart, length, atgloc)
          }

        } else {
          test_utr <- iswithincdsC(atgcheck[[3]], stopcheck[[3]], relstart+posstart, 1, obj$pos, atgloc, stoploc)
          if (checkcutrange) {
            test_range <- iswithincutrangeC(cutsites, cut.range, relstart+posstart, 1, atgloc)
          }

        }

        if (test_utr) {
          # mutation is in coding sequence so we need to consider frame shifts
          if ((length %% 3) != 0) {
            if (input_atg == F) {
              output_fs <- T
            }
          }

          # size matters if in frame
          if (length > cutoff.large) {
            output_lg <- T
          } else {
            output_sm <- T
          }
        } else {
          # mutation is in UTR
          output_utr <- T
        }

        # cut site positioning NHEJ
        if (checkcutrange) {
          if (test_range) {
            output_inrange <- output_inrange || T
          }
        }

        # deal with naming of the variant
        # here the positions are stored, the actual naming is done later
        if ((checkcutrange && test_range) || !checkcutrange) {
          # for naming of the mutation
          if (cigarsubs_woH[d] == "D") {
            bool_dels <- T
            if (dels[1] == "") {
              if (length == 1) {
                dels <- paste(checknegC(posstart+relstart),sep="")
              } else {
                dels <- paste(checknegC(posstart+relstart),"_",checknegC(posstart+relstart+length-1),sep="")
              }
            } else {
              if (length == 1) {
                dels <- append(dels,paste(checknegC(posstart+relstart),sep=""))
              } else {
                dels <- append(dels,paste(checknegC(posstart+relstart),"_",checknegC(posstart+relstart+length-1),sep=""))
              }
            }

            # indelseq
            temp_indelseq <- getreferenceC(index,chr,lower=atgloc+posstart+relstart-1,upper=atgloc+posstart+relstart+length-2)

          } else if (cigarsubs_woH[d] == "I") {
            ## inserted bases
            bool_ins <- T
            ins_temp <- seqinsertedC(paste(parsed_seq),cigarsubs_woH,d)

            if (ins_loc[1] == "") {
              ins_loc <- paste(checknegC(posstart+relstart-1),"_",checknegC(posstart+relstart),sep="")
              ins_bps <- ins_temp
            } else {
              ins_loc <- append(ins_loc,paste(checknegC(posstart+relstart-1),"_",checknegC(posstart+relstart),sep=""))
              ins_bps <- append(ins_bps,ins_temp)
            }

            # indelseq
            temp_indelseq <- ins_temp
          }

          ## append if necessary
          if (indelseq == "") {
            indelseq <- temp_indelseq
          } else {
            indelseq <- paste(indelseq,"_",temp_indelseq,sep="")
          }

        }

      }
    }
  }

  ###############################################
  ### return
  return(list(output_fs, output_sm, output_lg, list(bool_dels,dels), list(bool_ins, ins_loc, ins_bps), indelseq, output_utr, output_inrange))
}

#' @title Profile the codingframe sequence
#' @description This function profiles the coding sequence for variants
#' @param fs If TRUE, a frameshift was already detected in previous analysis steps.
#' @inheritParams AlleleProfileR.parseleadseq
#' @inheritParams AlleleProfileR.determine.variants
#' @return List with elements: output_start, output_coding, output_fs, output_stop, output_pstop, length, output_wt, output_cryptic, seq, output_cryptic_start, output_cryptic_stop
#' @author Arne Bruyneel
#' @export
AlleleProfileR.parsecodingframe <- function(obj, gene, index, fs = F) {
  ## this function processes the codingframe. it doesn't matter whether it is identical to the WT here.
  ## the main concern of this function is assessing a functional start and stop codon, and whether there is a frameshift.

  ## parameters
  default_stopcodons <- c("TAG","TAA","TGA")

  # extract gene info
  atgloc <- gene$ATG
  chr <- gene$Chr
  stoploc <- gene$StopCodon
  starttype <- gene$StartType
  startshift <- gene$StartShift
  stoptype <- gene$StopType
  stopshift <- gene$StopShift

  ## output variables
  output_start <- NA # TRUE if ATG destroyed
  output_coding <- NA # TRUE if coding
  output_pstop <- F # TRUE if premature stop introduced
  output_stop <- NA # TRUE if actual stop is destroyed
  output_fs <- NA # TRUE if frameshift
  output_wt <- F # TRUE if the coding frame is WT
  output_cryptic <- F # TRUE if the cryptic start/stop
  length <- 0 # coding frame length in bps
  crypticresultsbool <- F
  output_cryptic_start <- NA
  output_cryptic_stop <- NA

  ## prelim calculations
  cigarsubs <- cigarsubsC(obj$cigar)
  startpostemp <- checkatgC(obj, gene)
  stoppostemp <- checkstopC(obj, gene)
  startfound <- startpostemp[3]
  stopfound <- stoppostemp[3]

  ## this function seggregates analysis based on whether the start and/or stop are present in the read. For the full analysis, both are required.

  codingseq <- AlleleProfileR.getcodingseq(obj, cigarsubs, gene, index)
  # note that the codingseq is a list of four.

  ###########################################
  ####### reference CDS
  ref_coding <- getreferenceC(index, chr, lower=atgloc, upper=stoploc+2)

  ###########################################
  ####### check for functional start ########
  ###########################################

  if (starttype == "N") {
    refstartcodon <- "ATG"

    # 1. the first three bps in the codingseq[[1]] are 'ATG'
    # 2. up or downstream cryptic start in frame
    # 3. there is no functional codingcrisprseq.

    if (substr(codingseq[[1]],1,3) == refstartcodon) {
      # 1. it has a functional start codon

      seq <- codingseq[[1]]
      output_coding <- T
      output_start <- F
      output_cryptic <- F

    } else {
      # start is destroyed
      output_start <- T
      # but the read may still be coding
      output_fs <- F

      # 2. up or downstream cryptic start and stop
      # determine if these alternate proteins are in frame with the origional protein
      # merge the codingseq with the pre-ATG sequence and post-stop sequence.

      cryptictestseq <- generalpastelongC(c(codingseq[[2]],codingseq[[1]],codingseq[[3]]))
      stopposcryptic <- codingseq[[4]]

      # stop parameterisation
      if (stoptype == "N") {
        stopcodons <- default_stopcodons
      }

      # determine cryptic codons
      cryptictest <- AlleleProfileR.cryptic(seq = cryptictestseq, stopoptions = list(stoptype, stopshift, stopposcryptic))

      if (dim(cryptictest[[1]])[1] > 0) {
        crypticresultsbool <- T

        crypticdata <- cryptictest[[1]]

        # to assess whether or not these cryptic codons are actually meaningful,
        # we'll do a pairwise aligment to see which one is most similar to the orginal exon.
        # and what its's alignment score is.
        mat <- Biostrings::nucleotideSubstitutionMatrix(match = 1, mismatch = -3, baseOnly = FALSE, type = "DNA")

        for (al in 1:dim(crypticdata)[1]) {
          cryptseq <- substring(cryptictestseq,crypticdata$start[al],min(crypticdata$stop[al],nchar(cryptictestseq)))
          Align <- Biostrings::pairwiseAlignment(Biostrings::DNAString(paste(ref_coding)), Biostrings::DNAString(paste(cryptseq)), substitutionMatrix = mat, gapOpening = 5, gapExtension = 2)
          crypticdata$alignscore[al] <- BiocGenerics::score(Align)
        }

        # select the one with the highest score
        selectionid <- which(crypticdata$alignscore == max(crypticdata$alignscore))
        # it is possible the multipe alignments have the same maximum value, and hence are selected.
        if (length(selectionid) > 1) {
          selectionid <- selectionid[1] # in case of multiple with identical score, pick the first
        }
        seq <- substring(cryptictestseq,crypticdata$start[selectionid],crypticdata$stop[selectionid])
        output_cryptic_start <- crypticdata$start[selectionid]
        output_cryptic_stop <- crypticdata$stop[selectionid]
        length <- nchar(seq)
      }

      # output results
      if (!crypticresultsbool) {
        # 3. no coding frame
        seq <- NA
        output_coding <- F
        output_cryptic <- F
      } else {
        # so some cryptic gene/protein with start/stop
        output_cryptic <- T
        output_coding <- F
      }
    }
  } else {
    ### do default start codon

    ## treat as a regular sequence.

    seq <- codingseq[[1]]
    output_coding <- NA
    output_start <- NA
  }

  ###########################################
  ######## check for functional stop ########
  ###########################################

  # 1. check first if there is a frame shift.
  # 1a. if not, the last three bp are the real stop codon.
  # 1b. if yes, check whether a stop codon is created

  # 2. check whether there is a stopcodon created before the actual stop codon.

  if (!is.na(seq) && !output_cryptic) {

    ###########################################
    ######## assess whether it's an active CDS
    # functional start if seq != NULL
    # no fs: !fs
    # or a fs but a cryptic codon: output_cryptic

    if (!fs) {
      # 1a. so no frame shift.
      output_fs <- fs

      ## stop parameterisation
      if (stoptype == "N") {
        stopcodons <- default_stopcodons
        stopcodonscryptic <- NULL

        if (mathorC(stopcodons %in% substr(seq,nchar(seq)-2,nchar(seq)))) {
          # the last codon is the stop codon.
          output_stop <- F

          ###############################################
          ### premature stopcodon?
          codons <- codonsC(seq, 1+startshift, nchar(seq)-3)
          # here the the start shift was included for the codons.

          if (mathorC(default_stopcodons %in% codons)) {
            output_pstop <- T # introduction of a premature stop codon is considered a TRUE

            # which codon?
            codon_stops <- NA
            for (c in 1: length(codons)) {
              if (mathorC(default_stopcodons %in% codons[c])) {
                if (is.na(codon_stops[1])) {
                  codon_stops <- c
                } else {
                  codon_stops <- append(codon_stops,c)
                }
              }
            }

            length <- 3*codon_stops[1]

            seq <- substring(codingseq[[1]], 1+startshift, length+startshift)

            # for a premature stop codon, save the postion for plotting
            output_cryptic_start <- startpostemp[[2]]+startshift
            output_cryptic_stop <- startpostemp[[2]]+3*codon_stops[1]+startshift
            # so the stop position here is the end of the last base pair!

          } else {
            ###############################################
            ################# in the running for being a WT
            ###############################################
            output_pstop <- F
            length <- nchar(seq)

            # but it only makes sense to look for SNPs if the algorithm hasn't selected a cryptic coding seq.

            if (!crypticresultsbool) {
              #
              # does the read cds have the same length as the reference cds?
              if (length == nchar(ref_coding)) {
                # if the length is identical, establish whether the sequence is identical
                if (ref_coding == seq) {
                  output_wt <- T
                }
              }

            }
          }

        } else {
          output_stop <- T # destruction of the actual stop codon is considered a TRUE
          length <- NA

          ###############################################
          ### premature stopcodon?
          codons <- codonsC(seq,1,nchar(seq)-3)

          if (mathorC(default_stopcodons %in% codons)) {
            output_pstop <- T # introduction of a premature stop codon is considered a TRUE

            # which codon?
            codon_stops <- NA
            for (c in 1: length(codons)) {
              if (mathorC(default_stopcodons %in% codons[c])) {
                if (is.na(codon_stops[1])) {
                  codon_stops <- c
                } else {
                  codon_stops <- append(codon_stops,c)
                }
              }
            }

            length <- 3*codon_stops[1]
            seq <- substring(codingseq[[1]], 1+startshift, length+startshift)

          } else {
            output_pstop <- F
            length <- NA
          }
        }

      } else {
        ## not a normal stop

        output_stop <- NA

        ###############################################
        ### premature stopcodon?
        codons <- codonsC(seq, 1 + startshift, nchar(seq)-3)
        # here the the start shift was included for the codons.

        if (mathorC(default_stopcodons %in% codons)) {
          output_pstop <- T # introduction of a premature stop codon is considered a TRUE

          # which codon?
          codon_stops <- NA
          for (c in 1: length(codons)) {
            if (mathorC(default_stopcodons %in% codons[c])) {
              if (is.na(codon_stops[1])) {
                codon_stops <- c
              } else {
                codon_stops <- append(codon_stops,c)
              }
            }
          }

          length <- 3*codon_stops[1]
          seq <- substring(codingseq[[1]], 1+startshift, length+startshift)
          # for a premature stop codon, save the postion for plotting
          output_cryptic_start <- startpostemp[[2]]+startshift
          output_cryptic_stop <- startpostemp[[2]]+3*codon_stops[1]+startshift

        } else {
          ###############################################
          ################# in the running for being a WT
          ###############################################
          output_pstop <- F
          length <- nchar(seq)

          # but it only makes sense to look for SNP if the algorithm hasn't selected a cryptic coding seq.

          if (!crypticresultsbool) {
            #
            # does the read cds have the same length as the reference cds?
            if (length == nchar(ref_coding)) {
              # if the length is identical, establish whether the sequence is identical
              if (ref_coding == seq) {
                output_wt <- T
              }
            }

          }
        }

      } # normal - exon-exon stop

    } else {
      ###############################################
      ### so a frame shift, stop created?

      output_fs <- T

      # extend the search range beyond stop: using available sequenced information.

      codons <- codonsC(paste(seq,codingseq[[3]],sep=""),1+startshift)

      if (mathorC(default_stopcodons %in% codons)) {
        output_pstop <- T # introduction of a premature stop codon is considered a TRUE

        # which codon?
        codon_stops <- NA
        for (c in 1: length(codons)) {
          if (mathorC(default_stopcodons %in% codons[c])) {
            if (is.na(codon_stops[1])) {
              codon_stops <- c
            } else {
              codon_stops <- append(codon_stops,c)
            }
          }
        }

        length <- 3*codon_stops[1]
        seq <- substring(codingseq[[1]], 1+startshift, length+startshift)

        # for a premature stop codon, save the postion for plotting
        output_cryptic_start <- startpostemp[[2]]+startshift
        output_cryptic_stop <- startpostemp[[2]]+3*codon_stops[1]+startshift

      } else {
        output_pstop <- F
        length <- NA
      }

    }
  }

  # return
  return(list(output_start,output_coding,output_fs,output_stop,output_pstop,length,output_wt,output_cryptic,seq,output_cryptic_start,output_cryptic_stop))
}

#' @title Determine the allele name of HDR sequences
#' @description This function determines the name of the variant that would be introduced if homologous recombination with the template were to occur.
#' @param alternate Path to .fasta file with HDR sequences
#' @inheritParams AlleleProfileR.map
#' @inheritParams AlleleProfileR.batch
#' @return Data.frame with the HDR variant names for each gene in the gene table.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.alternatereference <- function(config, alternate) {
  # gene table
  genes <- config[[2]]
  # config[[3]] is the real index
  index <- config[[3]]
  # other
  cutoff <- config[[4]]
  index <- config[[3]]
  ignore.snp <- config[[5]]
  ignore.single <- config[[6]]
  cut.range <- config[[7]]
  ignore.chimeric <- config[[9]]
  cutoff.large <- config[[10]]
  chimeric.max.insertion.size <- config[[11]]
  suppress.messages <- config[[12]]

  # make sure that the bam file exists
  if (!file.exists("files/index/alternate.bam")) {
    cmd <- paste0("bwa mem ", index, " ", alternate, " | samtools view -Sb - > files/index/alternate.bam")
    message(cmd, "\n");
    system(cmd)
  }

  ###
  bamobj <- AlleleProfileR.bam("files/index/alternate.bam")
  bamobj_clean <- AlleleProfileR.qc.simple(bamobj)
  bamobj_clean$posend <- readposendC(bamobj_clean)
  bamobj_clean$chimera <- FALSE

  # output table
  output <- data.frame(gene = genes$Gene, allele = NA)

  for (i in 1:dim(genes)[1]) {
    geneinfo <- genes[i,]
    selected_bam <- bamobj_clean[which(paste(bamobj_clean$qname) == paste(geneinfo$Gene)),]
    variants <- AlleleProfileR.determine.variants(selected_bam, index, geneinfo, cutoff.large,
                                                  ignore.snp, cut.range, ignore.chimeric,
                                                  chimeric.max.insertion.size, suppress.messages = T)
    if (dim(variants)[1] > 0) {
      output$allele[which(output$gene == paste(geneinfo$Gene))] <- variants$allele[1]
    }
  }

  return(output)
}

AlleleProfileR.processWT <- function(pipe_config, gene.id = NA) {
  ##
  if (is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    # get data on gene
    index <- pipe_config[[3]][1]
    geneselected <- pipe_config[[2]][gene.id,]
    # wt sequence
    wtseq <- getreferenceC(file = index, chr=geneselected$Chr, lower=geneselected$Start-5, upper=geneselected$Stop+5)
    # make a dummy object (WT) to pipe through the algorith to set the WT parameters in the boolean plot.
    dummyobj <- data.frame(qname = "WT", rname=geneselected$Chr, pos = geneselected$Start-5, seq = wtseq, cigar = paste(nchar(wtseq),"M",sep=""), posend = NA, flag=0, qwidth=nchar(wtseq))
    dummyobj$seq <- as.character(dummyobj$seq)
    dummyobj$cigar <- as.character(dummyobj$cigar)
    dummyprocessed <- AlleleProfileR.getreads(dummyobj, chr=geneselected$Chr, pcrrange=c(geneselected$Start-10,geneselected$Stop+10), range=c(geneselected$Start,geneselected$Stop), purify=T)
    return(AlleleProfileR.determine.variants(dummyprocessed, index=index, gene=geneselected, cutoff.large = pipe_config[[10]], suppress.messages = T))
  }
}


#' @title Bin reads based on genomic postition with respect to certain boundries
#' @description This function will assign the reads within a certain PCR pre-amplification region to
#' different bins, depending on whether they do/do not/or partly overlap with the ROI.
#' A read will be classified as 'A' if it is within the PCR amplification range (pcrrange).
#' A read will be classified as 'B' or 'C' if it lies upstream and partly overlaps OR lies
#' downstream and partly overlaps with the region of interest (range). Finally, a read will be flagged as 'D'
#' if it fully overlaps with the ROI.
#' @param chr Chromosome
#' @param pcrrange Genomic range of that was pre-amplified by PCR before sequencing.
#' @param range Genomic range of interest, where variants will be called.
#' @param purify If set to TRUE, low qual reads will be discarded. Can be executed separately by AlleleProfileR.qc.simple.
#' @inheritParams AlleleProfileR.execute
#' @return Bam data.frame with added columns 'bin', 'select', 'lower', and 'upper'.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.binreads <- function(bamtable, chr, pcrrange, range, purify=T) {
  # bins:
  # A: within PCR range
  # B: partial overlap with ROI, pre
  # C: partial overlap with ROI, post
  # D: full overlap with ROI
  # select is full overlap and hence identical to D.

  # extract parameters
  lower <- range[1]
  upper <- range[2]
  pcrlower <- pcrrange[1]
  pcrupper <- pcrrange[2]

  # discard crap sequences if purify is set
  if (purify) {
    bamtable <- AlleleProfileR.qc.simple(bamtable)
  }

  # chromosome selection.
  bam_df <- bamtable[(!is.na(bamtable$rname) & (bamtable$rname == paste(chr))), ]
  # region selection
  bam_df$posend <- readposendC(bam_df)
  pcrregionrows <- which(bam_df$pos > pcrlower & bam_df$posend < pcrupper)
  bam_df <- bam_df[pcrregionrows,]

  # no gurantee that there will be hits
  if (dim(bam_df)[1] > 0) {
    # prelim
    bam_df$select <- FALSE
    bam_df$lower <- FALSE
    bam_df$upper <- FALSE
    bam_df$bin <- NA
    # split for chimera
    bam_df$chimera <- FALSE
    bam_df$chimera[which((duplicated(bam_df$qname) | duplicated(bam_df$qname, fromLast = TRUE)))] <- TRUE
    bam_df_nochimera <- bam_df[bam_df$chimera == F,]
    bam_df_chimera <- bam_df[bam_df$chimera == T,]

    # first deal with non-chimera's
    if (dim(bam_df_nochimera)[1] > 0) {
      bam_df_nochimera$lower <- (bam_df_nochimera$pos < lower)
      bam_df_nochimera$upper <- (bam_df_nochimera$posend > upper)

      # apply using mutate
      `%>%` <- dplyr::`%>%`
      nochim_intermediate_output <- data.frame(pos = bam_df_nochimera$pos, posend = bam_df_nochimera$posend) %>% dplyr::rowwise() %>% dplyr::mutate(bin = binassignC(pos, posend, y = c(lower,upper)))
      bam_df_nochimera$bin <- nochim_intermediate_output$bin

      # select = D
      bam_df_nochimera$select <- bam_df_nochimera$bin == "D"

    } else {
      bam_df_nochimera <- as.data.frame(matrix(nrow = 0, ncol = (dim(bam_df)[2]+6)))
    }

    if (dim(bam_df_chimera)[1] > 0) {
      # using Rcpp
      bam_df_chimera[,c("select", "bin", "lower", "upper")] <- binassignChimericC(bam_df_chimera, c(lower, upper, pcrlower, pcrupper))

    } else {
      bam_df_chimera <- as.data.frame(matrix(nrow = 0, ncol = (dim(bam_df)[2]+6)))
    }

    # merge nochimera and chimera
    bam_df_bins <- rbind(bam_df_nochimera,bam_df_chimera)

  } else {
    # return a table with zero rows.
    bam_df_bins <- as.data.frame(matrix(nrow = 0, ncol = (dim(bam_df)[2]+6)))
  }

  # export
  return(bam_df_bins)
}

#' @title Bin reads based on genomic postition with respect to certain boundries
#' @description This function will only select reads that fully overlap with a genomic range (range),
#' and will ignore partly overlapping reads.
#' @inheritParams AlleleProfileR.binreads
#' @return Bam data.frame with added columns 'bin', 'select', 'lower', and 'upper'.
#' Only reads for which selected is TRUE will be retained (bin is D).
#' @author Arne Bruyneel
#' @export
AlleleProfileR.getreads <- function(bamtable, chr, pcrrange, range, purify=T) {
  ## link to bin reads
  binoutput <- AlleleProfileR.binreads(bamtable, chr, pcrrange, range, purify)
  selectedrows <- which(binoutput$select == T)
  #
  return(binoutput[selectedrows,])
}

#' @title Basic QC function for BAM data.frames
#' @description This function will discard low qual reads based on the flags. However, note that this function only employs really basic filtering. More advanced read filtering or preprocessing may be required and can be accomplished using AlleleProfileR.preprocess and external software.
#' @inheritParams AlleleProfileR.binreads
#' @return bam data.frame
#' @author Arne Bruyneel
#' @export
AlleleProfileR.qc.simple <- function(bamtable) {
  # filtering is based on the FLAG bits
  # return only the non-discarded reads
  return(bamtable[which(bamQCC(bamtable$flag)==F),])
}

#' @title Load a .bam file as a data.frame
#' @description This function will import a .bam file and stores it  as a data.frame.
#' @param file Path to a .bam file
#' @author Arne Bruyneel
#' @references Based on: https://gist.github.com/SamBuckberry/9914246
#' @export
AlleleProfileR.bam <- function(file) {
  # get the bam object
  bamobj <- Rsamtools::scanBam(file)
  bam_field <- names(bamobj[[1]])

  # helper function
  bamunlist <- function (x){
    x1 <- x[[1L]]
    if (is.factor(x1)){
      structure(unlist(x), class = "factor", levels = levels(x1))
    } else {
      do.call(c, x)
    }
  }

  list <- lapply(bam_field, function(y) bamunlist(lapply(bamobj, "[[", y)))
  bam_df <- do.call("data.frame", list)
  names(bam_df) <- bam_field

  # manage type
  bam_df$cigar <- as.character(bam_df$cigar)
  bam_df$rname <- as.character(bam_df$rname)
  bam_df$seq <- as.character(bam_df$seq)
  bam_df$mrnm <- as.character(bam_df$mrnm)
  bam_df$strand <- as.character(bam_df$strand)
  bam_df$qname <- as.character(bam_df$qname)

  return(bam_df)
}

#' @title Identify cryptic coding sequences
#' @description Determine whether there is a cryptic startcodon that may give rise to a cryptic 'protein'.
#' For example, if the endogenous startcodon is destroyed, but there is an alternative startcodon downstream.
#' @param seq Sequence, provide sequence including both the existing pre and post UTR regions
#' @param stopoptions List defining the stop conditions of the current exon: does it end in a stop codon,
#' or is it one of many exons. The first element of this list is the type of stopcodon (N for standard).
#' The second element is the shift in the codons, for example if the exon length is not a multiple of 3.
#' The third is the alternative stop codon position if it isn't a traditional stop codon (NULL for default).
#' @return List of the cryptic proteins, and all start and stop codons respectively.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.cryptic <- function(seq, stopoptions = list("N", 0, NULL)) {
  ### parameters
  default_stops <- c("TAG","TAA","TGA")

  # output tables
  cryptcodons <- data.frame(matrix(ncol = 3, nrow = 0))
  colnames(cryptcodons) <- c("codon", "i", "c")
  # i: position
  # c: shift

  # this will get all the potential starts and stops, but they aren't necessary in frame.
  for (i in 1:(nchar(seq)-2)) {
    currentcodon <- codonselectC(seq, def = i, select = 0, shift = 0)

    # check for start
    if (currentcodon == "ATG") {
      temp <- data.frame("ATG",i,0)
      names(temp) <- c("codon", "i","c")
      cryptcodons <- rbind(cryptcodons,temp)
    }

    ## check for stops
    if (mathorC(default_stops %in% currentcodon)) {
      temp <- data.frame("stop",i,0)
      names(temp) <- c("codon", "i","c")
      cryptcodons <- rbind(cryptcodons,temp)
    }
  }

  ## check for an alternate stop
  if (stopoptions[[1]] != "N") {
    temp <- data.frame("alternate",stopoptions[[3]],stopoptions[[2]])
    names(temp) <- c("codon", "i","c")
    cryptcodons <- rbind(cryptcodons,temp)
  }

  ## crypticproteins output table
  cryptprotein <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(cryptprotein) <- c("start", "stop", "length", "type")
  cryptproteinreject <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(cryptproteinreject) <- c("start", "stop", "length", "type")


  # link start codons to appropriate stop codons
  if (dim(cryptcodons[cryptcodons$codon == "ATG",])[1] > 0 && dim(cryptcodons[cryptcodons$codon == "stop",])[1] > 0) {
    for (g in which(cryptcodons$codon == "ATG")) {
      # first select stops/alternats with stop later than the start
      putativestops <- cryptcodons[cryptcodons$codon != "ATG" & cryptcodons$i[g] < (cryptcodons$i+cryptcodons$c),]
      # then reduce the list such that the length is a multiple of 3, or if an alternant a multiple of three plus the cshift.

      if (dim(putativestops)[1] > 0) {
        # dummy output temp
        tempput <- data.frame(matrix(ncol = 4, nrow = 0))
        colnames(tempput) <- c("start", "stop", "length", "type")

        # determine cryptic start-stop combo's
        for (l in 1:dim(putativestops)[1]) {
          # this list included exons with codons not in frame.
          # then reduce the list such that the length is a multiple of 3, or if an alternant a multiple of three plus the cshift.
          if (putativestops$codon[l] == "alternate") {
            temp <- data.frame(cryptcodons$i[g], putativestops$i[l]+2+putativestops$c[l], 1+2+putativestops$i[l]+putativestops$c[l]-cryptcodons$i[g], "alt")
            names(temp) <- c("start", "stop", "length", "type")

            if (temp$length %% 3 == stopoptions[[2]] && temp$length > 8) {
              tempput <- rbind(tempput,temp)
            } else {
              cryptproteinreject <- rbind(cryptproteinreject,temp)
            }

          } else {
            temp <- data.frame(cryptcodons$i[g], putativestops$i[l]+2+putativestops$c[l], 1+2+putativestops$i[l]+putativestops$c[l]-cryptcodons$i[g], "N")
            names(temp) <- c("start", "stop", "length", "type")

            if (temp$length %% 3 == 0 && temp$length > 8) {
              tempput <- rbind(tempput,temp)
            } else {
              cryptproteinreject <- rbind(cryptproteinreject,temp)
            }
          }
        }

        if (dim(tempput)[1] > 0) {
          # there may be none or multiple
          # the first stop will be the stop, hence the one that results in the shortest exon.
          selectput <- which(tempput$length == min(tempput$length))
          # execute the selection
          cryptprotein <- rbind(cryptprotein,tempput[selectput,])
        }
      }
    }
  }

  # set some label
  colnames(cryptprotein) <- c("start", "stop", "length", "type")

  ## return..
  return(list(cryptprotein, cryptcodons, cryptproteinreject))
}

AlleleProfileR.getcodingseq <- function(obj, cigarsubs, gene, index) {
  # note that AlleleProfileR.checkstart or AlleleProfileR.checkstop positions relate to the position in the cigarstring.
  # but this does not equal the position in the sequence. Indeed, deletions are listed in the cigarstring but are lacking in the sequence.

  # execute this function on the unified crisprseq. However in this case the stopcodon search will have to be executed on the unified seq too.

  # extract gene info
  atgloc <- gene$ATG
  chr <- paste(gene$Chr)
  stoploc <- gene$StopCodon
  starttype <- gene$StartType
  stoptype <- gene$StopType
  pcrstart <- gene$PCRStart
  pcrstop <- gene$PCRStop

  # prelim checks
  startobj <- checkatgC(obj, gene)
  stopobj <- checkstopC(obj, gene)
  startpos <- startobj[2]
  startfound <- startobj[3]
  stoppos <- stopobj[2]
  stopfound <- stopobj[3]

  # the sequence may have some clipping at the start or end, check the cigar and make certain this is removed, when doing stop/stop position inputation.
  seq <- paste(obj$seq)

  ## the assumtion here is that the read is in the middle of the CDS and that it potentially lacks the start and or beginning.
  ## however it is possible that the start and stop are both downstream of the posend, or upstream of pos.
  ## assess this first

  if (atgloc < obj$pos && stoploc < obj$pos) {
    ## the CDS start is upstream
    cds <- getreferenceC(file = index, chr = chr, lower = atgloc, upper = stoploc+2)
    preseq <- getreferenceC(file = index, chr = chr, lower = pcrstart, upper = atgloc-1)

    # the sequence might start with 'S' in the cigar
    if (cigarsubs[2] == "S") {
      start <- as.numeric(cigarsubs[1])+1
    } else {
      start <- 1
    }
    # the seq might also end in a 'S'
    if (tail(cigarsubs, n=1) == "S") {
      stop <- nchar(seq)-as.numeric(tail(cigarsubs, n=2)[1])
    } else {
      stop <- nchar(seq)
    }

    postseq <- paste(getreferenceC(file = index, chr = chr, lower = stoploc+3, upper = obj$pos-1),substring(seq,start,stop),sep= "")

    # return
    return(list(cds,preseq,postseq,stoploc-pcrstart+1))

  } else if (atgloc > obj$posend && stoploc > obj$posend) {
    ## the CDS start is downstream
    cds <- getreferenceC(file = index, chr = chr, lower = atgloc, upper = stoploc+2)

    # the sequence might start with 'S' in the cigar
    if (cigarsubs[2] == "S") {
      start <- as.numeric(cigarsubs[1])+1
    } else {
      start <- 1
    }
    # the seq might also end in a 'S'
    if (tail(cigarsubs, n=1) == "S") {
      stop <- nchar(seq)-as.numeric(tail(cigarsubs, n=2)[1])
    } else {
      stop <- nchar(seq)
    }

    preseq <- paste(substring(seq,start,stop),getreferenceC(file = index, chr = chr, lower = obj$posend, upper = atgloc-1),sep="")
    postseq <- getreferenceC(file = index, chr = chr, lower = stoploc+3, upper = pcrstop)

    # return
    returnstoppos <- nchar(paste(preseq))+nchar(paste(cds))-2

    return(list(cds,preseq,postseq,returnstoppos))

  } else {

    # if startfound is false
    if (!startfound) {
      # read in the reference sequence for the missing CDS region before the start of the alignment
      # start at atgloc and end one bp before obj$pos
      missingstart <- getreferenceC(file = index, chr = chr, lower = atgloc, upper = obj$pos-1)
      # and add the remainder of the read sequence

      # the sequence might start with 'S' in the cigar
      if (cigarsubs[2] == "S") {
        start <- as.numeric(cigarsubs[1])+1
      } else {
        start <- 1
      }

    } else {
      start <- 0 # this is the start position to use for extracting the coding seq, start is the A in ATG.
      currentpos <- 0 # this is the current seq position in the seq
      current <- 0 # this is the char in the cigarstring
      found <- F # has the start position been recovered. since startpos is not NULL it is guaranteed that the position will be found.

      #
      while (!isTRUE(found) & (current+2 <= length(cigarsubs))) {
        current <- current+2
        step <- as.numeric(cigarsubs[current-1]) # potential added value

        if (cigarsubs[current]== "H") {
          # the hard clipped seq is not present in the final read
        } else if (cigarsubs[current] == "S" && current != length(cigarsubs)) {
          # the soft clipped seq IS present in the final read
          start <- start + step
        } else if (cigarsubs[current] == "D") {
          start <- start # deletion hence the next matched bases will have the same position as the deleted ones, if they would have not been deleted.
          currentpos <- currentpos + step # however in the cigar string the deletions are mentioned.
        } else if (cigarsubs[current] == "I") {
          if (currentpos + step < startpos) {
            start <- start + step
          } else if (currentpos + step == startpos) {
            found <- T
            start <- start + step
          } else {
            if (currentpos > startpos) {
              found <- T
            } else {
              # partial only.
              found <- T
              start <- start + startpos-currentpos
            }
          }
          #
          currentpos <- currentpos + step
        } else if (cigarsubs[current] == "M") {
          if (currentpos + step < startpos) {
            start <- start + step
          } else if (currentpos + step == startpos) {
            found <- T
            start <- start + step
          } else {
            if (currentpos > startpos) {
              found <- T
            } else {
              # partial only.
              found <- T
              start <- start + startpos-currentpos
            }
          }
          #
          currentpos <- currentpos + step
        }
      }
    }

    # if stopfound is false
    if (!stopfound) {
      if (tail(cigarsubs, n=1) == "S") {
        stop <- nchar(seq)-as.numeric(tail(cigarsubs, n=2)[1])-2
      } else {
        stop <- nchar(seq)-2
      }
      # add some more reference till the stop codon
      missingstop <- getreferenceC(file = index, chr = chr, lower = obj$posend+1, upper = stoploc+2)

    } else {
      stop <- 0 # this is the stop position to use for extracting the coding seq
      currentpos <- 0 # this is the current seq position in the seq
      current <- 0 # this is the char in the cigarstring
      found <- F # has the start position been recovered. since stoppos is not NULL it is guaranteed that the position will be found.

      #
      while (!isTRUE(found) & (current+2 <= length(cigarsubs))) {
        current <- current+2
        step <- as.numeric(cigarsubs[current-1]) # potential added value

        if (cigarsubs[current]== "H") {
          # the hard clipped seq is not present in the final read
        } else if (cigarsubs[current] == "S" && current != length(cigarsubs)) {
          # the soft clipped seq IS present in the final read
          stop <- stop + step
        } else if (cigarsubs[current] == "D") {
          stop <- stop # deletion hence the next matched bases will have the same position as the deleted ones, if they would have not been deleted.
          currentpos <- currentpos + step # however in the cigar string the deletions are mentioned.

        } else if (cigarsubs[current] == "I") {
          if (currentpos + step < stoppos) {
            stop <- stop + step
          } else if (currentpos + step == stoppos) {
            found <- T
            stop <- stop + step
          } else {
            if (currentpos > stoppos) {
              found <- T
            } else {
              # partial only.
              found <- T
              stop <- stop + stoppos-currentpos
            }
          }
          #
          currentpos <- currentpos + step

        } else if (cigarsubs[current] == "M") {
          if (currentpos + step < stoppos) {
            stop <- stop + step
          } else if (currentpos + step == stoppos) {
            found <- T
            stop <- stop + step
          } else {
            if (currentpos > stoppos) {
              found <- T
            } else {
              # partial only.
              found <- T
              stop <- stop + stoppos-currentpos
            }
          }
          #
          currentpos <- currentpos + step
        }
      }

      # we now know that the first base of the stop is present, but what about the subsequent two?
      bpendposoffset <- (stoploc+2)-obj$posend
      if (bpendposoffset > 0 && bpendposoffset < 3) {
        surplus <- getreferenceC(file = index, chr = chr, lower = stoploc+3-bpendposoffset, upper = stoploc+2)
      } else {
        surplus <- ""
      }
    }

    # return
    # [[1]] is the coding seq starting where the ATG would start
    # [[2]] pre ATG region
    # [[3]] post STOP region
    # [[4]] stoppos

    if (startfound && stopfound) {
      returnstoppos <- stop
      return(list(paste(substr(paste(seq),start,stop+2),surplus,sep=""), substr(paste(seq),1,start-1), substr(paste(seq),stop+3,nchar(paste(seq))), returnstoppos))

    } else if (!startfound && stopfound) {
      returnstoppos <- nchar(paste(missingstart)) + stop
      return(list(paste(missingstart,substr(paste(seq),start,stop+2),surplus,sep = ""), getreferenceC(file = index, chr = chr, lower = pcrstart, upper = atgloc-1), substr(paste(seq),stop+3,nchar(paste(seq))), returnstoppos))

    } else if (startfound && !stopfound) {
      returnstoppos <- stop + nchar(paste(missingstop))
      return(list(paste(substr(paste(seq),start,stop+2),missingstop,sep = ""), substr(paste(seq),1,start-1), getreferenceC(file = index, chr = chr, lower = stoploc+3, upper = pcrstop), returnstoppos))

    } else {
      returnstoppos <- nchar(paste(missingstart)) + stop + nchar(paste(missingstop))
      return(list(paste(missingstart,substr(paste(seq),start,stop+2),missingstop,sep = ""), getreferenceC(file = index, chr = chr, lower = pcrstart, upper = atgloc-1), getreferenceC(file = index, chr = chr, lower = stoploc+3, upper = pcrstop), returnstoppos))
    }

  }

}

#' @title Summary function
#' @description This function determines and plots the relative occurence of boolean features for all samples and all genes.
#' @param table Sumarized the results as a table?
#' @param plot Plot results?
#' @param param Parameter to plot. Default is wt.
#' @inheritParams AlleleProfileR.setup
#' @inheritParams AlleleProfileR.batch
#' @return Summary table and/or heat map. The color of the heat map represents proportion, whereas the tile label indicates total number of alleles.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.batch.summary <- function(config, table = F, plot = T, param = "wt", subset = NULL) {
  # the aim of thos function is to make one table with all datasets for all genes
  # and all samples which can be used for summary plotting

  # determine the subset parameters
  # collect the data
  if (is.list(subset)) {
    if (length(subset) == 2) {
      soi <- subset[[1]]
      goi <- subset[[2]]

      samplestable <- config[[1]][soi,]
      genestable <- config[[2]][goi,]
    } else {
      stop("Illegal subset parameters")
    }

  } else {
    if (is.null(subset)) {
      samplestable <- config[[1]]
      genestable <- config[[2]]
    } else {
      stop("Illegal subset parameters")
    }
  }

  if (dim(samplestable)[1]*dim(genestable)[1] > 0) {

    # make table
    summary_table <- data.frame(matrix(nrow = 0, ncol = 4))
    colnames(summary_table) <- c('sample', 'gene', 'n.alleles', 'prop')

    for (a in 1:dim(samplestable)[1]) {
      for (b in 1:dim(genestable)[1]) {
        ##
        temp <- data.frame(matrix(nrow = 1, ncol = 4))
        colnames(temp) <- c('sample', 'gene', 'n.alleles', 'prop')
        temp$sample <- samplestable$Sample[a]
        temp$gene <- genestable$Gene[b]
        #
        summary_table <- rbind(summary_table, temp)
      }
    }

    # loop through file list

    for (i in 1:dim(summary_table)[1]) {
      tempfile <- paste("files/output/",summary_table$sample[i],"_",summary_table$gene[i],"_plot.csv",sep="")

      if (file.exists(tempfile)) {
        temp_data <- read.csv(tempfile, header = T)
        summary_table$n.alleles[i] <- dim(temp_data)[1]
        summary_table$prop[i] <- sum(temp_data[,param]*temp_data$count)/sum(temp_data$count)
      }

    }

    # making the plots
    if (plot) {
      p <- ggplot2::ggplot(summary_table, ggplot2::aes(y=sample,x=gene, fill = 100*prop, label = sprintf("%1.0f", n.alleles))) +
        ggplot2::geom_tile() + ggplot2::geom_text(size=4,colour = "black") +
        ggplot2::scale_fill_gradient2(low = "red", high = "blue", midpoint=50, name=paste("% ", param, sep="")) + ggplot2::theme_classic()

      print(p)
    }

    if (table) {
      return(summary_table)
    }

  }

}

#' @title Allelelic variant distribution summary and plotting function
#' @description This function determines summary statistics and plots
#' barcharts of the allelic variants, for either coding sequence length or read counts.
#' @param pipe_config congifuration object
#' @param sample.id Sample id, from samples object.
#' @param gene.id Gene id, from genes table.
#' @param plotparam If 1, the coding frame length will be plotted. If 2, the read count will be plotted. If 3, read proportion will be plotted.
#' @param alternate Alternate reference for labeling the HDR variant, as defined by AlleleProfileR.alternatereference.
#' @param title If TRUE, a title will be included in the graph.
#' @param axis.text.size The size of the axis labels. Default is 8.
#' @param legend.text.size The size of the legend labels. Default is 6.
#' @param ylabels Print ylabels. Default is TRUE.
#' @param order ordering variable
#' @param display_other Display the 'other' allele. Default is TRUE.
#' @param emptyrow Add emptyrow bool. Default is TRUE.
#' @param addwt Add addwt bool. Default is TRUE.
#' @inheritParams AlleleProfileR.setup
#' @inheritParams AlleleProfileR.batch.summary
#' @return Table and/or plot.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.sample.distribution <- function(pipe_config, sample.id = NA, gene.id = NA, plot = TRUE, plotparam = 1, alternate = NULL,
                                               title = TRUE, axis.text.size = 8, legend.text.size = 6,
                                               display_other = TRUE, ylabels = TRUE, order = NULL, emptyrow = TRUE, addwt = TRUE) {
  #
  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    sampleselected <- pipe_config[[1]][sample.id,]
    geneinfo <- pipe_config[[2]]
    geneselected <- geneinfo[gene.id,]
    # test first if this file exists.
    filename_plot <- paste("files/output/",sampleselected$Sample,"_",geneselected$Gene,"_plot.csv",sep="")

    # start
    start <- F

    # test if the filename exists
    if (file.exists(filename_plot)) {
      temp_data <- read.csv(filename_plot, header = T)

      if (!display_other) {
        # get rid of 'other' as allele, if present
        if ("Other" %in% unique(temp_data$allele)) {
          temp_data <- temp_data[-which(temp_data$allele == "Other"),]
        }
      }

      if (dim(temp_data)[1] > 0) {
        start <- T
      }
    }

    if (start) {
      summary_table <- data.frame(allele = rep(NA,dim(temp_data)[1]), count = NA, prop = NA, wt = NA,
                                  length = NA, coding = NA, atg=NA, col = NA)

      alternateplot <- FALSE
      alternateplotunpure <- FALSE

      for (i in 1:dim(summary_table)[1]) {
        summary_table$allele[i] <- paste(temp_data$allele[i])
        summary_table$count[i] <- as.numeric(temp_data$count[i])
        summary_table$prop[i] <- as.numeric(100*temp_data$count[i]/sum(temp_data$count[1:dim(summary_table)[1]]))
        summary_table$wt[i] <- temp_data$wt[i]
        summary_table$length[i] <- temp_data$codinglength[i]
        summary_table$coding[i] <- temp_data$coding[i]
        summary_table$atg[i] <- temp_data$atg[i]
        if (is.na(summary_table$length[i])) {
          summary_table$length[i] <- -1
        }
        if (temp_data$inrange[i]) {
          summary_table$col[i] <- "NHEJ"
        } else {
          summary_table$col[i] <- "Other"
        }

      }

      # deal with alternate
      if(is.data.frame(alternate)) {
        alternateallele <- paste(alternate$allele[which(alternate$gene == geneselected$Gene)])
        if (length(alternateallele) > 0) {
          found <- F
          for (g in 1:length(alternateallele)) {
            # test for pure HDR
            if (alternateallele[g] %in% unique(summary_table$allele)) {
              summary_table$col[which(summary_table$allele == alternateallele[g])] <- "HDR"
              summary_table$allele[which(summary_table$allele == alternateallele[g])] <- paste(alternateallele[g]," (HDR)", sep="")
              found <- TRUE
            }
          }

          # basically pure alternate was not found,
          # but it could be that the current read is a combo of both HDR and indel (call this unpure)
          # exclude this first
          unpurefound <- F

          for (g in 1:length(alternateallele)) {
            # fragments of the allele name.
            splitalternate <- strsplit(alternateallele[g], split = "[.]")[[1]]
            splitalternate <- splitalternate[2:length(splitalternate)]
            # basically, to be considered an unpure HDR, the allele needs to contain these fragments, and some other ones.

            for (q in 1:dim(summary_table)[1]) {
              # only consider entries which are not HDR, WT, nor Other.
              if (summary_table$col[q] != "HDR" & summary_table$allele[q] != "WT" & summary_table$allele[q] != "Other") {
                tempsplit <- strsplit(summary_table$allele[q], split = "[.]")[[1]]
                tempsplit <- tempsplit[2:length(tempsplit)]

                tcount <- 0

                for (y in splitalternate) {
                  if (y %in% tempsplit) {
                    tcount <- tcount + 1
                  }
                }

                if (tcount == length(splitalternate)) {
                  # all HDR allele fragments were found
                  summary_table$col[q] <- "HDR-NHEJ"
                  summary_table$allele[q] <- paste(summary_table$allele[q]," (HDR-NHEJ)", sep="")
                  unpurefound <- T
                }

              }
            }
          }

          if (found & ! unpurefound) {
            alternateplot <- TRUE

          } else if (found & unpurefound) {
            alternateplot <- TRUE
            alternateplotunpure <- TRUE

          } else if (!found & unpurefound) {
            alternateplot <- FALSE
            alternateplotunpure <- TRUE

          } else {
            alternateplot <- FALSE

          }

        } else {
          alternateplot <- FALSE
        }

      } else {
        alternateplot <- FALSE
      }

      # add empty row at the top to make it fit with the alignment:
      if (emptyrow) {
        summary_table <- rbind(summary_table,c("",as.numeric(0),as.numeric(0),as.numeric(0),as.numeric(0),as.numeric(0),as.numeric(0),""))
      }

      if ("WT" %in% unique(summary_table$allele)) {
        summary_table$col[which(summary_table$allele == "WT")] <- "WT"
        if (!is.null(order)) {
          summary_table$allele <- factor(summary_table$allele, levels = c(order, ""))
        }

      } else {
        if (addwt) {
          summary_table <- rbind(summary_table,c("WT",as.numeric(0),as.numeric(0),as.numeric(1),nchar(getreferenceC(file = pipe_config[[3]], chr = geneinfo$Chr[gene.id], lower = geneinfo$ATG[gene.id], upper = geneinfo$StopCodon[gene.id]+2)),1,0,"WT"))
          if (!is.null(order)) {
            summary_table$allele <- factor(summary_table$allele, levels = c(order, "WT", ""))
          }
        } else {
          summary_table$allele <- factor(summary_table$allele, levels = c(order))
        }
      }

      # deal with other
      if ("Other" %in% unique(summary_table$allele)) {
        summary_table$col[which(summary_table$allele == "Other")] <- "Other"
      }

      ## deal with the colors
      if ("Other" %in% unique(summary_table$allele) || "Other" %in% unique(summary_table$col)) {
        if(alternateplot & !alternateplotunpure) {
          if (length(unique(summary_table$allele)) > 3) {
            cols <- c("orange3","gray80","gray80","steelblue2")
          } else {
            cols <- c("orange3","gray80","steelblue2")
          }
        } else if(alternateplot & alternateplotunpure) {
          if ("NHEJ" %in% summary_table$col) {
            cols <- c("orange3","red3","gray80","gray80","steelblue2")
          } else {
            cols <- c("orange3","red3","gray80","steelblue2")
          }
        } else if(!alternateplot & alternateplotunpure) {
          if ("NHEJ" %in% summary_table$col) {
            cols <- c("red3","gray80","gray80","steelblue2")
          } else {
            cols <- c("red3","gray80","steelblue2")
          }
        } else {
          if (length(unique(summary_table$allele)) > 2) {
            cols <- c("gray80","gray80","steelblue2")
          } else {
            cols <- c("gray80","steelblue2")
          }
        }
      } else {
        if(alternateplot & !alternateplotunpure) {
          if (length(unique(summary_table$allele)) > 2) {
            cols <- c("orange3","gray80","steelblue2")
          } else {
            cols <- c("orange3","steelblue2")
          }
        } else if(alternateplot & alternateplotunpure) {
          if ("NHEJ" %in% summary_table$col) {
            cols <- c("orange3","red3","gray80","steelblue2")
          } else {
            cols <- c("orange3","red3","steelblue2")
          }
        } else if(!alternateplot & alternateplotunpure) {
          if ("NHEJ" %in% summary_table$col) {
            cols <- c("red3","gray80","steelblue2")
          } else {
            cols <- c("red3","steelblue2")
          }
        } else {
          if (length(unique(summary_table$allele)) > 1) {
            cols <- c("gray80","steelblue2")
          } else {
            cols <- c("steelblue2")
          }
        }
      }

      ## make sure everything is numerical
      summary_table$length <- as.numeric(summary_table$length)
      summary_table$count <- as.numeric(summary_table$count)
      summary_table$prop <- as.numeric(summary_table$prop)
      summary_table$col <- factor(summary_table$col, levels = c("HDR", "HDR-NHEJ", "NHEJ", "Other", "WT"))

      # prepare plots
      if (plot) {
        ##
        # what variable to plot?
        if (plotparam == 1) {
          plotcol <- summary_table[,"length"]
          plotylab <- "Exon CDS length"
        } else if (plotparam == 2) {
          plotcol <- summary_table[,"count"]
          plotylab <- "Read count"
        } else if (plotparam == 3) {
          plotcol <- summary_table[,"prop"]
          plotylab <- "% reads"
        } else {
          stop("Illegal plotparam value.")
        }

        ##
        p <- ggplot2::ggplot(data=summary_table, ggplot2::aes(x=allele, y=plotcol, fill = col)) +
          ggplot2::scale_fill_manual(values = cols) + ggplot2::geom_bar(stat="identity") +
          ggplot2::ylab(plotylab) + ggplot2::xlab("Allele variant") + ggplot2::theme_classic() +
          ggplot2::coord_flip() + ggplot2::theme(axis.text.y = ggplot2::element_text(size = axis.text.size),
                                                 axis.text.x = ggplot2::element_text(size = axis.text.size),
                                                 axis.title.x = ggplot2::element_text(vjust = -0.5),
                                                 legend.position="none",legend.key = ggplot2::element_blank(),
                                                 legend.text = ggplot2::element_text(size = legend.text.size),
                                                 legend.spacing = grid::unit(0.2,"cm")) +
          ggplot2::scale_x_discrete(labels = function(x) AlleleProfileR.labelwrapper(x))

        if (title) {
          p <- p + ggplot2::ggtitle(paste("Sample: ",sampleselected$Sample,"\n","Gene: ",geneselected$Gene, sep=""))
        }

        if (!ylabels) {
          p <- p + ggplot2::theme(axis.title.y=ggplot2::element_blank(), axis.text.y=ggplot2::element_blank()) # , axis.ticks.x=element_blank()

        }

        return(list(summary_table,p))
      } else {
        return(summary_table)
      }
    } else {
      cat("File does not exist...")
    }
  }
}

#' @title Allelelic variant distribution summary and plotting function for boolean outcome variables
#' @description This function determines summary statistics and plots
#' heatmaps of the allelic variants.
#' @param plotparam names of the parameters to plot
#' @inheritParams AlleleProfileR.sample.distribution
#' @return Table and/or plot.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.sample.distribution.boolean <- function(pipe_config, sample.id = NA, gene.id = NA, plot = TRUE, plotparam = c("wt",'fs','snp','atg','coding','stop','pstop','sm','lg','utr','cryptic','error'),
                                                       alternate = NULL, title = TRUE, axis.text.size = 8, legend.text.size = 6, display_other = T, ylabels = TRUE, order = NULL) {
  #
  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")
  } else {
    sampleselected <- pipe_config[[1]][sample.id,]
    geneinfo <- pipe_config[[2]]
    geneselected <- geneinfo[gene.id,]
    # test first if this file exists.
    filename_plot <- paste("files/output/",sampleselected$Sample,"_",geneselected$Gene,"_plot.csv",sep="")

    # start
    start <- F

    # test if the filename exists
    if (file.exists(filename_plot)) {
      temp_data <- read.csv(filename_plot, header = T)
      start <- T
    }

    if (start) {
      if (!display_other) {
        # get rid of 'other' as allele, if present
        if ("Other" %in% unique(temp_data$allele)) {
          temp_data <- temp_data[-which(temp_data$allele == "Other"),]
          temp_data$allele <- factor(temp_data$allele)
        }
      }

      # mark alternate
      temp_data$allele <- paste(temp_data$allele)
      temp_data$col <- NA

      if(is.data.frame(alternate)) {
        alternateallele <- paste(alternate$allele[which(alternate$gene == geneselected$Gene)])

        if (length(alternateallele) > 0) {
          # find pure HDR
          for (g in 1:length(alternateallele)) {
            if (alternateallele[g] %in% unique(temp_data$allele)) {
              temp_data$col[which(temp_data$allele == alternateallele[g])] <- "HDR"
              temp_data$allele[which(temp_data$allele == alternateallele[g])] <- paste(alternateallele[g]," (HDR)", sep="")
            }
          }

          # find unpure HDR-NHEJ hybrid
          for (g in 1:length(alternateallele)) {
            # fragments of the allele name.
            splitalternate <- strsplit(alternateallele[g], split = "[.]")[[1]]
            splitalternate <- splitalternate[2:length(splitalternate)]
            # basically, to be considered an unpure HDR, the allele needs to contain these fragments, and some other ones.

            for (q in 1:dim(temp_data)[1]) {
              # only consider entries which are not HDR, WT, nor Other.
              if (paste(temp_data$col[q]) != "HDR" & paste(temp_data$allele[q]) != "WT") {
                tempsplit <- strsplit(paste(temp_data$allele[q]), split = "[.]")[[1]]
                tempsplit <- tempsplit[2:length(tempsplit)]

                tcount <- 0

                for (y in splitalternate) {
                  if (y %in% tempsplit) {
                    tcount <- tcount + 1
                  }
                }

                if (tcount == length(splitalternate)) {
                  # all HDR allele fragments were found
                  temp_data$allele[q] <- paste(temp_data$allele[q]," (HDR-NHEJ)", sep="")
                }

              }
            }
          }

        }
      }

      ## generate summary table
      summary_table <- data.frame(allele = paste(temp_data$allele))
      summary_table$allele <- as.character(summary_table$allele)

      # what variable to plot?
      if (mathandC(plotparam %in% colnames(temp_data))) {
        temp_table_attach <- as.data.frame(temp_data[,plotparam])
        colnames(temp_table_attach) <- plotparam
        summary_table <- cbind(summary_table,temp_table_attach)

      } else {
        stop("Illegal plotparam value.")
      }

      if ("WT" %in% unique(summary_table$allele)) {
        # do nothing
        if (!is.null(order)) {
          summary_table$allele <- factor(summary_table$allele, levels = order)
        }

      } else {
        ## get WT values
        processedwt <- AlleleProfileR.processWT(pipe_config, gene.id = gene.id)
        wtvaluecols <- c("wt",'fs','snp','atg','coding','stop','pstop','sm','lg','utr','cryptic','error')
        wtvalues <- c(processedwt$wt,processedwt$fs,processedwt$snp,processedwt$atg,processedwt$coding,processedwt$stop,
                      processedwt$pstop,processedwt$sm,processedwt$lg,processedwt$utr,processedwt$cryptic,processedwt$error)
        selectedwtvalues <- vector()
        for (i in 1:length(plotparam)) {
          selectedwtvalues <- append(selectedwtvalues, wtvalues[which(wtvaluecols == plotparam[i])])
        }
        summary_table <- rbind(summary_table,c("WT",selectedwtvalues))
        if (!is.null(order)) {
          summary_table$allele <- factor(summary_table$allele, levels = c(order, "WT"))
        }
      }

      ## make certain values are numeric
      for (c in 2:dim(summary_table)[2]) {
        summary_table[,c] <- as.numeric(summary_table[,c])
      }

      ## make sure that there are no values larger than 1, this is only possible in snp
      if ("snp" %in% plotparam) {
        summary_table$snp[which(summary_table$snp > 1)] <- 1
      }

      # prepare plots
      if (plot) {
        ### reformat the data
        summary_table.m <- reshape2::melt(summary_table)

        if (!is.null(order)) {
          summary_table.m$allele <- factor(summary_table.m$allele, levels = order)
        }

        ###
        p <- ggplot2::ggplot(summary_table.m, ggplot2::aes(variable, allele)) + ggplot2::geom_tile(ggplot2::aes(fill = value), colour = "white") +
          ggplot2::scale_fill_gradient(low = "white", high = "cornflowerblue") + ggplot2::xlab("Parameter") + ggplot2::ylab("Allele variant") + ggplot2::theme_classic() +
          ggplot2::theme(axis.text.y = ggplot2::element_text(size = axis.text.size),
                         axis.text.x = ggplot2::element_text(size = axis.text.size),
                         axis.title.x = ggplot2::element_text(vjust = -0.5),
                         legend.position="none",legend.key = ggplot2::element_blank(),
                         legend.text = ggplot2::element_text(size = legend.text.size),
                         legend.spacing = grid::unit(0.2,"cm")) +
          ggplot2::scale_y_discrete(labels = function(x) AlleleProfileR.labelwrapper(x))

        if (title) {
          p <- p + ggplot2::ggtitle(paste("Sample: ",sampleselected$Sample,"\n","Gene: ",geneselected$Gene, sep=""))
        }

        if (!ylabels) {
          p <- p + ggplot2::theme(axis.title.y=ggplot2::element_blank(), axis.text.y=ggplot2::element_blank()) # , axis.ticks.x=element_blank()

        }

        return(list(summary_table,p))
      } else {
        return(summary_table)
      }
    } else {
      cat("File does not exist...")
    }
  }
}


#' @title Summary statistics of the profiled alleles
#' @description This function generates summary statistics of the profiled alleles of a sample.
#' @param profiledvariants Variants data.frame, as defined by AlleleProfileR.determine.variants.
#' @inheritParams AlleleProfileR.setup
#' @inheritParams AlleleProfileR.batch.recompute
#' @param alternateallele Alternate allele name
#' @return Detailed summary table. Allele: allele name, count: read counts, qname: identifier of a representative read, wt: wild type coding sequence,
#' snp: no of SNPs, atg: ATG destroyed, coding: coding for a protein, coding length: length of the exon, fs: frame shift present,
#' stop: stop destroyed, pstop: premature stop inserted, sm: small indel, lg: large indel, utr: indel in UTR region,
#' cryptic: cryptic coding frame present, error: errors in analysis, seq: read sequence, cdsseq: coding frame sequence,
#' pos: start position, cigar: cigar string, indelseq: indel sequences.
#' @author Arne Bruyneel
#' @export
AlleleProfileR.summary.profiled.alleles <- function(profiledvariants, cutoff=0, ignore.single = F,
                                                    top = 0, alternateallele = NULL) {
  if (dim(profiledvariants)[1] > 0) {
    # list of most common alleles, taking the cutoff into consideration.
    alleles <- unique(profiledvariants$allele)
    # get seq, pos, and cigar of of the most common alleles

    output <- data.frame(allele = alleles, count = NA, qname = NA, wt = NA, snp = NA, atg = NA, coding = NA, codinglength = NA,
                         fs = NA, stop = NA, pstop = NA, sm = NA, lg = NA, utr = NA, cryptic = NA, inrange = NA, error = NA, seq=NA, cdsseq=NA,
                         pos=NA, cigar=NA, indelseq=NA, cryptic_start = NA, cryptic_stop = NA)

    for (i in 1:dim(output)[1]) {
      temprows <- which(paste(profiledvariants$allele) == paste(output$allele[i]))
      temprowslength <- profiledvariants$qwidth[temprows]
      temprow <- temprows[which.max(temprowslength)]
      # take the sequence with the longuest read length with this allele form
      for (l in 4:17) {
        tempcol <- which(colnames(profiledvariants) == colnames(output)[l])
        output[i,l] <- mean(profiledvariants[temprows,tempcol])
      }

      output$qname[i] <- paste(profiledvariants$name[temprow])
      output$count[i] <- length(temprows)
      output$allele[i] <- paste(profiledvariants$allele[temprow])
      output$seq[i] <- paste(profiledvariants$unifiedseq[temprow])
      output$cdsseq[i] <- paste(profiledvariants$cdsseq[temprow])
      output$pos[i] <- profiledvariants$unifiedpos[temprow]
      output$cigar[i] <- paste(profiledvariants$unifiedcigar[temprow])
      output$indelseq[i] <- paste(profiledvariants$indelseq[temprow])
      output$cryptic_start[i] <- paste(profiledvariants$cryptic_start[temprow])
      output$cryptic_stop[i] <- paste(profiledvariants$cryptic_stop[temprow])
    }

    # total count, used for percent based cutoff
    totalcount <- dim(profiledvariants)[1]
    # compute cut-off value
    cutoffp <- cutoff*totalcount
    # apply the filter
    if (ignore.single) {
      output <- output[which(output$count > max(cutoffp,1)),]

    } else {
      output <- output[which(output$count > cutoffp),]
    }

    if (top > 0) {
      if (!is.null(alternateallele)) {
        if (length(alternateallele) > 0) {
          rowselect <- c()
          for (g in 1:length(alternateallele)) {
            if (alternateallele[g] %in% unique(output$allele)) {
              rowselect <- c(which(output$allele == alternateallele[g]),rowselect)
            }
          }
          rowselect <- unique(c(which(output$count %in% tail(sort(output$count),top)), rowselect))
          output <- output[rowselect,]
        } else {
          output <- output[which(output$count %in% tail(sort(output$count),top)),]
        }
      } else {
        output <- output[which(output$count %in% tail(sort(output$count),top)),]
      }
    }

  } else {
    output <- as.data.frame(matrix(0,nrow=0,ncol=24))
  }

  return(output)
}


#' @title Alignment plot function
#' @description THis function plots sequence alignments.
#' @param max.insertion.size The maximum length of an insertion to be shown in the
#' legend. Larger insertions will be collapsed. Default is 20.
#' @param ins.size The size of the symbols representing insertions within the plot. Default is 5.
#' @param legend.symbol.size The size of the symbols indicating insertions in the legend. Default is ins.size.
#' @param plot.text.size The size of the text inside the plot. Default is 2.
#' @param alignmenttype Type for Biostrings::pairwiseAlignment operation to determine whether two alleles are identical. Default is "local-global".
#' @inheritParams AlleleProfileR.batch
#' @inheritParams AlleleProfileR.sample.distribution
#' @inheritParams AlleleProfileR.sample.distribution
#' @return Alignment plot
#' @author Arne Bruyneel
#' @references
#' This function incorporates some of the plotting features of CrispRVariants (Helen Lindsay).
#' \itemize{
#'   \item Lindsay H, Burger A, Biyong B, Felker A, Hess C, Zaugg J, Chiavacci E, Anders C, Jinek M, Mosimann C, Robinson MD. CrispRVariants charts the mutation spectrum of genome engineering experiments. Nature Biotechnology 2016;34:701702. doi: 10.1038/nbt.3628.
#' }
#' @export
AlleleProfileR.plot.alignment <- function(config, sample.id = NA, gene.id = NA, max.insertion.size = 20,
                                         ins.size = 5, legend.symbol.size = ins.size, legend.text.size = 6, plot.text.size = 2,
                                         axis.text.size = 8, alternate = NULL, alignmenttype = "local-global") {

  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    # locate the data
    sampleselected <- config[[1]][sample.id,]
    geneselected <- config[[2]][gene.id,]
    filename_plot <- paste("files/output/",sampleselected$Sample,"_",geneselected$Gene,"_plot.csv",sep="")

    # test if the filename exists
    if(file.exists(filename_plot)) {
      # use the plot file
      cigar_summary <- read.csv(filename_plot, header = T)
      cigar_summary$cigar <- as.character(cigar_summary$cigar)
      cigar_summary$col <- NA

      # reference
      ref <- Biostrings::DNAStringSet(getreferenceC(config[[3]], geneselected$Chr, geneselected$Start, geneselected$Stop))

      # get rid of 'other' as allele, if present
      if ("Other" %in% unique(cigar_summary$allele)) {
        cigar_summary <- cigar_summary[-which(cigar_summary$allele == "Other"),]
      }

      # mark alternate
      cigar_summary$allele <- paste(cigar_summary$allele)

      if(is.data.frame(alternate)) {
        alternateallele <- paste(alternate$allele[which(alternate$gene == geneselected$Gene)])
        if (length(alternateallele) > 0) {
          # find pure HDR
          for (g in 1:length(alternateallele)) {
            if (alternateallele[g] %in% unique(cigar_summary$allele)) {
              cigar_summary$col[which(cigar_summary$allele == alternateallele[g])] <- "HDR"
              cigar_summary$allele[which(cigar_summary$allele == alternateallele[g])] <- paste(alternateallele[g]," (HDR)", sep="")
            }
          }

          # find unpure HDR-NHEJ hybrid
          for (g in 1:length(alternateallele)) {
            # fragments of the allele name.
            splitalternate <- strsplit(alternateallele[g], split = "[.]")[[1]]
            splitalternate <- splitalternate[2:length(splitalternate)]
            # basically, to be considered an unpure HDR, the allele needs to contain these fragments, and some other ones.

            for (q in 1:dim(cigar_summary)[1]) {
              # only consider entries which are not HDR, WT, nor Other.
              if (paste(cigar_summary$col[q]) != "HDR" & paste(cigar_summary$allele[q]) != "WT") {
                tempsplit <- strsplit(paste(cigar_summary$allele[q]), split = "[.]")[[1]]
                tempsplit <- tempsplit[2:length(tempsplit)]

                tcount <- 0

                for (y in splitalternate) {
                  if (y %in% tempsplit) {
                    tcount <- tcount + 1
                  }
                }

                if (tcount == length(splitalternate)) {
                  # all HDR allele fragments were found
                  cigar_summary$allele[q] <- paste(cigar_summary$allele[q]," (HDR-NHEJ)", sep="")
                }

              }
            }
          }


        }
      }

      if (dim(cigar_summary)[1] > 0) {

        # determine whether some alleles are identical, eventhough the algorithm gave them a distinct allele name.
        # perform this determination based on the seq entry in cigar_summary
        # if the alleles are identical, sequence alignment score needs to match the length of the shortest sequence

        text_alignsidentalleles <- NA

        if (dim(cigar_summary)[1] > 1) {
          # only if more than one allele

          # make output dataframe for the alignments
          alignsidentalleles <- data.frame(matrix(ncol=dim(cigar_summary)[1],nrow=dim(cigar_summary)[1]))
          colnames(alignsidentalleles) <- paste(cigar_summary$allele)

          # loop through data and execute the paired alignments
          # lets assume that the rows are the references
          # and that the columns are the samples
          for (r in 1:dim(alignsidentalleles)[1]) {
            # retrieve the correct reference
            reference <- Biostrings::DNAStringSet(paste(cigar_summary$seq[r]))

            for (c in 1:r) {
              # do the pairwise alignments for all reads
              tempalign <- Biostrings::pairwiseAlignment(Biostrings::DNAStringSet(paste(cigar_summary$seq[c])), reference, type = alignmenttype)
              alignsidentalleles[r,c] <- Biostrings::pid(tempalign)
            }
          }

          # are there alleles with 100% match?
          for (r in 2:dim(alignsidentalleles)[1]) {
            for (c in 1:(r-1)) {
              if (alignsidentalleles[r,c] == 100) {
                if (is.na(text_alignsidentalleles)) {
                  text_alignsidentalleles <- paste("Notes: \n","Allele ",colnames(alignsidentalleles)[r]," and ",colnames(alignsidentalleles)[c]," appear to be identical.\n",sep = "")
                } else {
                  text_alignsidentalleles <- append(text_alignsidentalleles,paste("Allele ",colnames(alignsidentalleles)[r]," and ",colnames(alignsidentalleles)[c]," appear to be identical.\n",sep = ""))
                }
              }
            }
          }
        }

        # generate reference and alignments
        targetgr <- data.frame(chr=geneselected$Chr, start=geneselected$Start, end=geneselected$Stop, strand="+")
        targetgr <- GenomicRanges::makeGRangesFromDataFrame(targetgr)

        # trimming
        target_start <- BiocGenerics::start(targetgr)
        target_end <- BiocGenerics::end(targetgr)
        alns <- GenomicAlignments::sequenceLayer(Biostrings::DNAStringSet(cigar_summary$seq), cigar_summary$cigar, D.letter = "-", N.letter = "N")
        sq_len <- GenomicAlignments::width(alns)

        if (! is.null(cigar_summary$pos) & ! is.null(target_start) & ! is.null(target_end) ){
          trim_start <- target_start - (cigar_summary$pos - 1)

          if (any(trim_start < 0)){
            stop("dnaseq to be trimmed must start before the target location")
          }

          trim_end <- trim_start + (target_end - target_start)
          if (any(trim_end > sq_len)){
            stop("dnaseq is not long enough to trim to the target region")
          }
          alns <- XVector::subseq(alns, trim_start, trim_end)
        }

        alns <- as.character(alns)

        # Reverse alignment order, as ggplot geom_tile plots bottom up
        aln_chrs <- strsplit(c(rev(alns), Reference = as.character(ref)), "")
        names(aln_chrs) <- c(rev(paste(cigar_summary$allele)), "Reference")

        # Test that all alignments and reference have the same length
        if (! length(unique(lapply(aln_chrs, length))) == 1){
          stop("The reference sequence and the alignments must all have the same length")
        }

        temp <- t(as.data.frame(aln_chrs))
        rownames(temp) <- names(aln_chrs)
        longalns <- reshape2::melt(temp)

        ambig_codes <- c('K','M','R','Y','S','W','B','V','H','D')
        longalns$value <- as.character(longalns$value)
        longalns$value <- factor(longalns$value, levels = c(c("A", "C", "G", "T", "N", "-", ""), ambig_codes))
        longalns$isref <- as.character(ifelse(longalns$Var1 == "Reference", 1, 0.75))
        longalns_cols <- c(c('darkgreen', 'blue', 'orange', 'red', "#CCCCCC", "#FFFFFF"), rep("#CCCCCC", length(ambig_codes)))
        names(longalns_cols) <- c(c("A", "C", "G", "T", "N","-"), ambig_codes)

        # text collor
        longalns$text_cols <- ifelse(longalns$isref == 1, "#FFFFFF", "#000000")

        #################################################################
        # deal with order: WT, HDR, NHEJ
        orderalleles <- vector()
        # ref
        orderalleles <- append(orderalleles, which(levels(longalns$Var1) == "Reference"))
        # WT if present
        if ("WT" %in% longalns$Var1) {
          orderalleles <- append(which(levels(longalns$Var1) == "WT"),orderalleles)
        }

        # if alternates are present
        if(is.data.frame(alternate)) {
          alternateallele <- paste(alternate$allele[which(alternate$gene == geneselected$Gene)])
          if (length(alternateallele) > 0) {
            for (g in 1:length(alternateallele)) {
              tempnameallele <- paste(alternateallele[g]," (HDR)", sep="")
              if (tempnameallele %in% longalns$Var1) {
                orderalleles <- append(which(levels(longalns$Var1) == tempnameallele),orderalleles)
              }
            }
          }
        }

        # others
        '%!in%' <- function(x,y)!('%in%'(x,y))
        ordernulls <- which(c(1:length(levels(longalns$Var1))) %!in% orderalleles)
        if (length(ordernulls) > 0) {
          orderalleles <- append(ordernulls,orderalleles)
        }

        ## reorder
        longalns$Var1 <- factor(longalns$Var1, levels=levels(longalns$Var1)[orderalleles])

        #################################################################
        # do some adaptive color allocation:
        for (i in 1:dim(longalns)[1]) {
          if (longalns$isref[i] == 1) {
            # if it's the reference
            longalns$cols[i] <- longalns_cols[longalns$value[i]]
            # if T, make text black
            if (longalns$value[i] == "T") {
              longalns$text_cols[i] <- paste("#000000")
            }

          } else {
            # if it isn't the reference, the color will depend on whether that base matches the reference
            if (longalns$value[i] != longalns$value[which(longalns$Var2 == longalns$Var2[i] & longalns$isref == 1)]) {
              longalns$cols[i] <- paste("#cc0000")
            } else {
              longalns$cols[i] <- paste("#FFFFFF")
            }

          }
        }

        ################################################
        ## ticks and labels
        frame_start <- (geneselected$Start-geneselected$ATG)
        frame_start_offset <- frame_start %% 10
        frame_stop <- (geneselected$Stop-geneselected$ATG)
        frame_stop_offset <- frame_stop %% 10

        xtick.labs <- c(frame_start:frame_stop)

        for (l in 1:(length(xtick.labs))) {
          if (xtick.labs[l] >= 0) {
            xtick.labs[l] <- as.numeric(xtick.labs[l])+1
          }

          if (as.numeric(xtick.labs[l]) %% 10 != 0) {
            if (as.numeric(xtick.labs[l]) == -1) {
              # do nothing
            } else if (as.numeric(xtick.labs[l]) == 1) {
              # do nothing
            } else {
              xtick.labs[l] <- ""
            }
          }
        }
        xtick.breaks <- NULL

        ################################################
        ################# plot init

        # Change alpha values if only plotting the reference
        if (length(unique(longalns$Var1)) == 1) {
          alpha_v <- 0.9
        } else {
          alpha_v <- c(0.5,0.9)
        }

        # Plot aligned sequences
        p <- ggplot2::ggplot(longalns) +
          ggplot2::geom_tile(ggplot2::aes_(x = quote(Var2), y = quote(Var1), fill = quote(cols), alpha = quote(isref)), show.legend=F, height = 0.55) +
          ggplot2::geom_text(ggplot2::aes_(x = quote(Var2), y = quote(Var1), label = quote(value), colour = quote(text_cols)), size = plot.text.size, show.legend=F) +
          ggplot2::scale_alpha_manual(values = alpha_v, guide = "none") +
          ggplot2::ylab(NULL) + ggplot2::scale_fill_identity(guide = "none") +
          ggplot2::scale_colour_identity(guide = "none") +
          ggplot2::theme_classic() +
          ggplot2::theme(axis.text.y = ggplot2::element_text(size = axis.text.size),
                         axis.text.x = ggplot2::element_text(size = axis.text.size),
                         axis.title.x = ggplot2::element_text(vjust = -0.5),
                         legend.position = "bottom")+
          ggplot2::guides(fill=F)+ggplot2::xlab("")+
          ggplot2::scale_y_discrete(labels = function(x) AlleleProfileR.labelwrapper(x))

        if (is.null(xtick.labs)){
          # expand is the distance from the axis, multiplicative + additive
          p <- p + ggplot2::scale_x_continuous(expand = c(0,0.25), limits = c(-2, nchar(paste(ref))+2))
        } else {
          if (is.null(xtick.breaks)) {
            stopifnot(length(xtick.labs) == nchar(paste(ref)))
            p <- p + ggplot2::scale_x_continuous(expand = c(0,0.25), breaks = 1:nchar(paste(ref)), labels = xtick.labs, limits = c(-2, nchar(paste(ref))+2))
          } else {
            p <- p + ggplot2::scale_x_continuous(expand = c(0,0.25), breaks = xtick.breaks, labels = xtick.labs, limits = c(-2, nchar(paste(ref))+2))
          }
        }


        ################################################
        # mark the start / ATG
        if (geneselected$StartType == "N") {
          p <- p + ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start + 0.5, colour = "black", size = 0.5) +
            ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start+3.5, colour = "black", size = 0.5)
        } else {
          if (geneselected$StartShift == 0) {
            p <- p + ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start + 0.5, color = "black", size = 0.5) +
              ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start+3.5, linetype = "dotted", color = "lightslategray", size = 0.5)
          } else {
            p <- p + ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start + 0.5, color = "black", size = 0.5) +
              ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start + geneselected$StartShift + 0.5, linetype = "dotted", color = "lightslategray", size = 0.5) +
              ggplot2::geom_vline(xintercept = geneselected$ATG-geneselected$Start + geneselected$StartShift + 3.5, linetype = "dotted", color = "lightslategray", size = 0.5)
          }
        }

        ################################################
        # mark the codons
        codon_locs <- seq(geneselected$ATG-geneselected$Start + geneselected$StartShift + 6, min(geneselected$StopCodon,geneselected$Stop)-geneselected$Start+2, by = 3)
        p <- p + ggplot2::geom_vline(xintercept = codon_locs+0.5, linetype = "dotted", color = "lightslategray", size = 0.5)


        ################################################
        # mark the stop codon
        if (geneselected$StopCodon < geneselected$Stop) {
          # segregate by types
          if (geneselected$StopType == 'N') {
            p <- p + ggplot2::geom_vline(xintercept = geneselected$StopCodon-geneselected$Start + 0.5, colour = "black", size = 0.5) +
              ggplot2::geom_vline(xintercept = geneselected$StopCodon-geneselected$Start+3.5, colour = "black", size = 0.5)

          } else {
            if (geneselected$StopShift != 0) {
              p <- p + ggplot2::geom_vline(xintercept = geneselected$StopCodon - geneselected$Start + 3.5, size = 0.5, linetype = "dotted", color = "lightslategray")
              p <- p + ggplot2::geom_vline(xintercept = geneselected$StopCodon - geneselected$Start + 3.5 + geneselected$StopShift, colour = "black", size = 0.5)
            } else {
              p <- p + ggplot2::geom_vline(xintercept = geneselected$StopCodon - geneselected$Start + 3.5, colour = "black", size = 0.5)
            }

          }
        }

        ################################################
        # mark the cut sites
        tempcutsites <- strsplit(paste(geneselected$CutSites), ";")[[1]]
        tempcutsites <- as.numeric(tempcutsites)
        tempcutsitesrange <- config[[7]]

        if (length(tempcutsites) > 0) {
          for (c in tempcutsites) {
            p <- p + ggplot2::geom_vline(xintercept = c - geneselected$Start + 0.5, colour = "purple", size = 0.5, linetype="dashed")
          }
        }

        if (tempcutsitesrange > 0) {
          p <- p + ggplot2::geom_vline(xintercept = min(tempcutsites) - geneselected$Start - tempcutsitesrange + 0.5, colour = "orange", size = 0.5, linetype="dashed")
          p <- p + ggplot2::geom_vline(xintercept = max(tempcutsites) - geneselected$Start + tempcutsitesrange + 0.5, colour = "orange", size = 0.5, linetype="dashed")
        }


        ################################################
        ################# mark the insertions

        # get data on alleles with insertion
        cigar_summary$insdetected <- F

        # for all the alleles, determine whether there is an insertin that beeds to be plotted
        for (d in 1:dim(cigar_summary)[1]) {
          if (!is.null(unlist(gsubfn::strapply(paste(cigar_summary$allele[d]), "([[:digit:]]+)ins")))) {
            cigar_summary$insdetected[d] <- T
          } else {
            cigar_summary$insdetected[d] <- F
          }
        }

        insertionids <- which(cigar_summary$insdetected == T)
        uniquealleles <- unique(paste(cigar_summary$allele[insertionids]))
        # are there insertions?
        if (length(insertionids) > 0) {
          # make an insertions dataframe
          ins.sites <- data.frame(matrix(nrow=0, ncol=4))
          colnames(ins.sites) <- c("start", "seq", "count", "allele")

          # fill with information
          for (al in uniquealleles) {
            # retrieve insertion sites and sequences
            tempinsertioninfo <- inssitesC(paste(al))
            # how many insertions?
            no_ins <- length(tempinsertioninfo)/3
            tempout <- data.frame(matrix(nrow=no_ins, ncol=4))
            colnames(tempout) <- c("start", "seq", "count", "allele")
            tempout$allele <- al
            tempout$start <- geneselected$ATG-geneselected$Start + 1 + as.numeric(tempinsertioninfo[mathrangeC(1, length(tempinsertioninfo),3)])
            tempout$seq <- tempinsertioninfo[mathrangeC(3, length(tempinsertioninfo) + 1, 3)]
            tempout$count <- 1
            # this start location is not correct for insertions in gaps. those need to be shifted by -1.
            idswithgap <- which(as.numeric(tempinsertioninfo[mathrangeC(1, length(tempinsertioninfo), 3)]) + 1 != as.numeric(tempinsertioninfo[mathrangeC(2,length(tempinsertioninfo),3)]))
            tempout$start[idswithgap] <- tempout$start[idswithgap] - 1
            # negative values need to be shifted too
            isneg <- which(tempout$start < (geneselected$ATG-geneselected$Start + 1))
            tempout$start[isneg] <- tempout$start + 1

            # export
            ins.sites <- rbind(ins.sites,tempout)
          }

          # Insertion locations are determined by matching ins.sites$cigar with names(alns)
          ins_ord <- match(ins.sites$allele, levels(longalns$Var1))

          #
          ins_points <- data.frame(x = ins.sites[!is.na(ins_ord),"start"] - 0.5,
                                   y = na.omit(ins_ord) + 0.25,
                                   seq = ins.sites[!is.na(ins_ord),"seq"],
                                   count = as.integer(ins.sites[!is.na(ins_ord),"count"]))

          ins_points <- aggregate(ins_points$count, by = as.list(ins_points[,c(1:3)]), FUN = sum)
          colnames(ins_points) <- c("x", "y", "seq", "count")

          ## Merge multiple insertions at single plotting location, format to fixed width
          xy_locs <- paste(ins_points$x, ins_points$y, sep = "_")

          temp <- rowsum(ins_points$count, xy_locs)
          totals <- as.vector(temp)
          names(totals) <- rownames(temp)

          temp <- ! duplicated(xy_locs)
          wdths <- nchar(as.character(ins_points[temp, "seq"]))

          names(wdths) <- xy_locs[temp]
          splits <- split(ins_points$seq, xy_locs)

          # Collapse sequences longer than max.insertion.size
          x <- lapply(seq_along(splits), function(i){
            result <- as.character(na.omit(splits[[i]]))
            wdth <- wdths[[names(splits)[i]]]

            if (length(result) != 1){
              # If there are multiple sequences
              if (wdth > max.insertion.size | length(result) == 0){
                result <- sprintf("%sI (%s common alleles)", wdth, length(result))
              } else {
                # Collapse, one sequence per line
                result <- paste(result, collapse = ",\n")
              }
            } else {
              # If only one sequence
              if (wdth > max.insertion.size) result <- sprintf("%sI", wdth)
            }
            result
          })
          names(x) <- names(splits)

          new_seqs <- unlist(x)[unique(xy_locs)]
          max_seq_ln <- max(sapply(gsub("\n.*", "", new_seqs), nchar)) + 3
          new_seqs <- sprintf(paste0("%-",max_seq_ln,"s"), new_seqs)

          ins_points <- ins_points[!duplicated(ins_points[,c("x","y")]),]
          ins_points$seq <- new_seqs

          # Specify colours and shapes for insertion symbols
          # table of unique seq
          ins_points$lab <- NA
          tempunique <- unique(paste(ins_points$seq))
          uniqueinstable <- data.frame(lab=c(1:length(tempunique)),seq=tempunique)
          for (i in 1:length(ins_points$lab)) {
            ins_points$lab[i] <- uniqueinstable$lab[which(uniqueinstable$seq == ins_points$seq[i])]
          }

          # Indicate insertions
          p <- p + ggplot2::geom_point(data = ins_points, ggplot2::aes_(x = quote(x), y = quote(y)), size = ins.size, shape = 25, fill = "red", colour = "#000000")
          p <- p + ggplot2::geom_text(data = ins_points, ggplot2::aes_(x = quote(x), y = quote(y), label = quote(lab)), colour = "white", show.legend = T)
          p <- p + ggplot2::theme(legend.key = ggplot2::element_blank(),
                                  legend.text = ggplot2::element_text(size = legend.text.size),
                                  legend.spacing = grid::unit(0.2,"cm"))

          # create the insertions table
          colnames(uniqueinstable) <- c("ID","Sequence")

        }

        ################################################
        ################# mark the cryptic genes

        if (sum(cigar_summary$cryptic) > 0 && tempcutsitesrange == 0) {
          selrowcryptic <- which(cigar_summary$cryptic > 0)
          # store data in a table to make plotting easier
          crypticdatatable <- data.frame(matrix(nrow=2*length(selrowcryptic), ncol=2))
          colnames(crypticdatatable) <- c('x','y')

          # data
          tempdatacryptic <- cigar_summary[selrowcryptic,]

          # loop and analyse
          if (length(selrowcryptic) > 0) {
            for (c in 1:dim(tempdatacryptic)[1]) {
              # need to verify two things: (1) not NA, (2) not inside an insertion
              if (!is.na(as.numeric(tempdatacryptic$cryptic_stop[c])) && !is.na(as.numeric(tempdatacryptic$cryptic_start[c]))) {
                tempcigarcryptic <- cigarsubsC(tempdatacryptic[c,"cigar"])
                # do test (2)
                if (iswithininsertionC(tempcigarcryptic, as.numeric(tempdatacryptic$cryptic_start[c]))) {
                  crypticdatatable[2*c-1,] <- c(NA, which(levels(longalns$Var1) == tempdatacryptic$allele[c]))

                } else {
                  crypticdatatable[2*c-1,] <- c(tempdatacryptic$pos[c] - geneselected$Start - 1 +
                                                  as.numeric(tempdatacryptic$cryptic_start[c]) -
                                                  sum(cigarsubsinsertionsC(tempcigarcryptic, start = 0,
                                                                           end = as.numeric(tempdatacryptic$cryptic_start[c]),
                                                                           type = "base")) +
                                                  sum(cigarsubsdeletionsC(tempcigarcryptic, start = 0,
                                                                          end = as.numeric(tempdatacryptic$cryptic_start[c]),
                                                                          type = "base")),
                                                which(levels(longalns$Var1) == tempdatacryptic$allele[c]))
                }

                if (iswithininsertionC(tempcigarcryptic, as.numeric(tempdatacryptic$cryptic_stop[c]))) {
                  crypticdatatable[2*c,] <- c(NA, which(levels(longalns$Var1) == tempdatacryptic$allele[c]))

                } else {
                  crypticdatatable[2*c,] <- c(tempdatacryptic$pos[c] - geneselected$Start - 1 +
                                                as.numeric(tempdatacryptic$cryptic_stop[c]) + 1 -
                                                sum(cigarsubsinsertionsC(tempcigarcryptic,  start = 0,
                                                                         end = as.numeric(tempdatacryptic$cryptic_stop[c]),
                                                                         type = "base")) +
                                                sum(cigarsubsdeletionsC(tempcigarcryptic, start = 0,
                                                                        end = as.numeric(tempdatacryptic$cryptic_stop[c]),
                                                                        type = "base")),
                                              which(levels(longalns$Var1) == tempdatacryptic$allele[c]))
                }

              }
            }

            ## plot
            p <- p + ggplot2::geom_segment(ggplot2::aes(x = x + 0.5, y = y - 0.5, xend = x + 0.5, yend = y + 0.5, colour = "red"), data = crypticdatatable)

          }
        }

        ################################################
        ################# mark premature stop codons (start is maintained)

        if (sum(cigar_summary$pstop) > 0 && tempcutsitesrange == 0) {
          selrowpstop <- which(cigar_summary$pstop > 0)
          # store in table
          pstopdatatable <- data.frame(matrix(nrow=length(selrowpstop), ncol=2))
          colnames(pstopdatatable) <- c('x','y')

          # data
          tempdatapstop <- cigar_summary[selrowpstop,]

          # loop and analyse
          if (length(selrowpstop) > 0) {
            for (c in 1:dim(pstopdatatable)[1]) {
              # need to verify two things: (1) not NA, (2) not inside an insertion
              if (!is.na(as.numeric(tempdatapstop$cryptic_stop[c]))) {
                tempcigarpstop <- cigarsubsC(tempdatapstop[c,"cigar"])
                # do test (2)
                if (iswithininsertionC(tempcigarpstop, as.numeric(tempdatapstop$cryptic_stop[c]))) {
                  pstopdatatable[c,] <- c(NA, which(levels(longalns$Var1) == tempdatapstop$allele[c]))

                } else {
                  pstopdatatable[c,] <- c(tempdatapstop$pos[c] - geneselected$Start - 1 +
                                            as.numeric(tempdatapstop$cryptic_stop[c]) -
                                            sum(cigarsubsinsertionsC(tempcigarpstop,
                                                                     end = as.numeric(tempdatapstop$cryptic_stop[c]),
                                                                     type = "base")) +
                                            sum(cigarsubsdeletionsC(tempcigarpstop,
                                                                    end = as.numeric(tempdatapstop$cryptic_stop[c]),
                                                                    type = "base")),
                                          which(levels(longalns$Var1) == tempdatapstop$allele[c]))
                }

              }
            }

            ## plot
            p <- p + ggplot2::geom_segment(ggplot2::aes(x = x + 0.5, y = y - 0.5, xend = x + 0.5, yend = y + 0.5, colour = "red"), data = pstopdatatable)

          }
        }

        ########################################################################################################################
        ### return statements
        if (length(insertionids) > 0) {
          return(list(p,uniqueinstable,text_alignsidentalleles,levels(longalns$Var1)))
        } else {
          return(list(p,NA,text_alignsidentalleles,levels(longalns$Var1)))
        }

      }

    } else {
      stop("File does not exist...")
    }
  }
}


#' @title Plotting function
#' @description This is the main plotting function of this R-package.
#' @param plotparam barchart types
#' @param type full or count-only
#' @inheritParams AlleleProfileR.plot.alignment
#' @return AlleleProfileR.plot
#' @author Arne Bruyneel
#' @export
AlleleProfileR.plot <- function(config, sample.id = NA, gene.id = NA, max.insertion.size = 20,
                                ins.size = 5, legend.symbol.size = ins.size, legend.text.size = 6, plot.text.size = 2,
                                axis.text.size = 8, alternate = NULL, alignmenttype = "local-global", type="full", plotparam = c(2,1)) {
  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    # locate the data
    sampleselected <- config[[1]][sample.id,]
    geneselected <- config[[2]][gene.id,]
    # test first if this file exists.
    filename_plot <- paste("files/output/",sampleselected$Sample,"_",geneselected$Gene,"_plot.csv",sep="")

    # start
    start <- F

    # test if the filename exists
    if (file.exists(filename_plot)) {
      temp_data <- read.csv(filename_plot, header = T)

      if (dim(temp_data)[1] > 0) {
        start <- T
      }

    }

    if (start) {
      plotAlnslist <- AlleleProfileR.plot.alignment(config, sample.id, gene.id, max.insertion.size = max.insertion.size,
                                                   ins.size = ins.size, legend.symbol.size = ins.size, legend.text.size = legend.text.size,
                                                   plot.text.size = plot.text.size, axis.text.size = axis.text.size,
                                                   alternate = alternate)

      plotAlns <- plotAlnslist[[1]]
      uniqueinstable <- plotAlnslist[[2]]

      # are there duplicate alleles?
      if (!is.na(plotAlnslist[[3]][1])) {
        cat(plotAlnslist[[3]])
      }

      # are there insertions?
      if (is.data.frame(uniqueinstable)) {
        instable <- ggpubr::ggtexttable(uniqueinstable, rows = NULL, theme = ggpubr::ttheme("blank"))
      }

      if (type == "full") {

        ## created other plots
        plotA <- AlleleProfileR.sample.distribution(config, sample.id, gene.id, plot = TRUE, alternate = alternate,
                                                    title = FALSE, plotparam = plotparam[1], legend.text.size = legend.text.size,
                                                    axis.text.size = axis.text.size, display_other = F, ylabels = TRUE,
                                                    order = plotAlnslist[[4]], emptyrow = F)[[2]]
        plotB <- AlleleProfileR.sample.distribution(config, sample.id, gene.id, plot = TRUE, alternate = alternate,
                                                    title = FALSE, plotparam = plotparam[2], legend.text.size = legend.text.size,
                                                    axis.text.size = axis.text.size, display_other = F, ylabels = FALSE,
                                                    order = plotAlnslist[[4]], emptyrow = F)[[2]]
        plotC <- AlleleProfileR.sample.distribution.boolean(config, sample.id, gene.id, plot = TRUE, alternate = alternate,
                                                            plotparam = c("wt",'fs','snp','atg','coding','stop','pstop','sm','lg','utr','cryptic','error'),
                                                            title = FALSE, display_other = F, legend.text.size = legend.text.size, axis.text.size = axis.text.size,
                                                            ylabels = FALSE, order = plotAlnslist[[4]])[[2]]

        ###
        grid::grid.newpage()
        grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow = 6, ncol = 5)))
        define_region <- function(row, col, just){
          grid::viewport(layout.pos.row = row, layout.pos.col = col, just = just)
        }
        # arrange
        print(plotAlns, vp = define_region(row = 1:4, col = 1:5, just = "centre"))   # Span over two columns
        print(plotA, vp = define_region(row = 5:6, col = 1, just = "centre"))

        if (is.data.frame(uniqueinstable)) {
          print(plotC, vp = define_region(row = 5:6, col = 2:3, just = "centre"))
          print(plotB, vp = define_region(row = 5:6, col = 4, just = "centre"))
          if (dim(uniqueinstable)[1] > 5) {
            print(instable, vp = define_region(row = 5:6, col = 5, just = c("centre","top")))
          } else {
            print(instable, vp = define_region(row = 5, col = 5, just = c("centre","top")))
          }
        } else {
          print(plotC, vp = define_region(row = 5:6, col = 2:4, just = "centre"))
          print(plotB, vp = define_region(row = 5:6, col = 5, just = "centre"))
        }

      } else if (type == "count-only") {
        # counts
        plotA <- AlleleProfileR.sample.distribution(config, sample.id, gene.id, plot = TRUE, alternate = alternate,
                                                    title = FALSE, plotparam = plotparam[1], legend.text.size = legend.text.size,
                                                    axis.text.size = axis.text.size, display_other = F, ylabels = FALSE,
                                                    order = plotAlnslist[[4]], emptyrow = T, addwt = F)[[2]]


        ###
        grid::grid.newpage()
        grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow = 5, ncol = 5)))
        define_region <- function(row, col, just){
          grid::viewport(layout.pos.row = row, layout.pos.col = col, just = just)
        }
        # arrange
        print(plotAlns, vp = define_region(row = 1:4, col = 1:4, just = "centre"))   # Span over two columns
        print(plotA, vp = define_region(row = 1:4, col = 5, just = "centre"))

        if (is.data.frame(uniqueinstable)) {
          if (dim(uniqueinstable)[1] > 5) {
            print(instable, vp = define_region(row = 5, col = 1:5, just = c("centre","top")))
          } else {
            print(instable, vp = define_region(row = 5, col = 1:5, just = c("centre","top")))
          }
        }

      }

    } else {
      stop("File does not exist or is empty...")
    }
  }
}


#' @title Plotting function
#' @description This is function will plot the proportion NHEJ, HDR and WT.
#' @inheritParams AlleleProfileR.plot.alignment
#' @inheritParams AlleleProfileR.batch.summary
#' @inheritParams AlleleProfileR.batch
#' @param label Display value label above bars? Default is TRUE.
#' @param title Display title? Default is TRUE.
#' @return AlleleProfileR.plot.mutationtypes
#' @author Arne Bruyneel
#' @export
AlleleProfileR.plot.mutationtypes <- function(config, sample.id = NA, gene.id = NA, alternate = NULL, plot = T, axis.text.size = 6,
                                              label = T, title = T) {
  ##
  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    ## use data output from AlleleProfileR.sample.distribution
    tempdata <- AlleleProfileR.sample.distribution(config, sample.id, gene.id, plot = F, plotparam = 2, alternate = alternate)

    output <- data.frame(type=c('WT','NHEJ','HDR','HDR-NHEJ'), prop=NA, reads=NA)
    ## loop through the data
    for (i in 1:4) {
      output$prop[i] <- sum(tempdata[which(tempdata$col == paste(output$type[i])),'prop'])
      output$reads[i] <- sum(tempdata[which(tempdata$col == paste(output$type[i])),'count'])
    }

    # prepare plots
    if (plot) {
      ###
      cols <- c("orange3","red3","gray80","steelblue2")
      p <- ggplot2::ggplot(data=output, ggplot2::aes(x=type, y=prop, fill=type)) + ggplot2::scale_fill_manual(values = cols) +
        ggplot2::geom_bar(stat="identity") + ggplot2::ylab("Proportion (%)") +
        ggplot2::xlab("Allele variant type") + ggplot2::theme_classic() +
        ggplot2::ylim(0,100)+
        ggplot2::theme(axis.text.y = ggplot2::element_text(size = axis.text.size),
                       axis.text.x = ggplot2::element_text(size = axis.text.size),
                       axis.title.x = ggplot2::element_text(vjust = -0.5),
                       legend.position="none")

      if (label) {
        p <- p + ggplot2::geom_text(data=output, ggplot2::aes(x=type, y=prop, label=sprintf("%0.2f", round(prop, digits = 2)), vjust=-0.5))
      }

      if (title) {
        samplename <- config[[1]][sample.id,1]
        genename <- config[[2]][gene.id,1]
        p <- p + ggplot2::ggtitle(paste(samplename,genename,sep = " - "))
      }

      return(list(output,p))

    } else {
      return(output)

    }
  }

}


#' @title Seqlogo plot function
#' @description Plot the efficacy of base-editing as a sequence logo.
#' @param customrange Vector with start and stop position of the region to be analyzed/plotted.
#' @return plot ggseqlogo
#' @inheritParams AlleleProfileR.plot.alignment
#' @inheritParams AlleleProfileR.batch.summary
#' @inheritParams AlleleProfileR.plot
#' @author Arne Bruyneel
#' @references
#' \itemize{
#'   \item Wagih, O. ggseqlogo: a versatile R package for drawing sequence logos. Bioinformatics 2017;33(22):3645-3647.
#' }
#' @export
AlleleProfileR.plot.seqlogo <- function(config, sample.id = NA, gene.id = NA, customrange = c(NA,NA), plot = F,
                                   axis.text.size = 8) {

  if (is.na(sample.id) || is.na(gene.id)) {
    stop("Please provide data...")

  } else {
    # locate the data
    sampleselected <- config[[1]][sample.id,]
    geneselected <- config[[2]][gene.id,]
    filename_all <- paste("files/output/",sampleselected$Sample,"_",geneselected$Gene,"_all.csv",sep="")

    # range settings
    if (!is.na(customrange[1]) && !is.na(customrange[2])) {
      rangestart <- customrange[1]
      rangestop <- customrange[2]
    } else {
      rangestart <- geneselected$Start
      rangestop <- geneselected$Stop
    }

    # reference
    ref <- getreferenceC(config[[3]], geneselected$Chr, rangestart, rangestop)

    # prepare output data.frame
    outputtemp <- data.frame(abspos = c(rangestart:rangestop),
                             relpos = c((rangestart-geneselected$ATG):(rangestop-geneselected$ATG)),
                             ref = strsplit(ref, split="")[[1]], A=0, T=0, G=0, C=0, N=0)

    outputtemp$ref <- as.character(outputtemp$ref)

    # there is no 'zero' position
    for (l in 1:dim(outputtemp)[1]) {
      if (outputtemp$relpos[l] >= 0) {
        outputtemp$relpos[l] <- outputtemp$relpos[l]+1
      }
    }

    # test if the filename exists
    if(file.exists(filename_all)) {
      # use the plot file
      datatable <- read.csv(filename_all, header = T)
      datatable$unifiedcigar <- as.character(datatable$unifiedcigar)
      datatable$unifiedseq <- as.character(datatable$unifiedseq)

      # loop through each analysed read in the file
      # exclude 'Other' alleles
      if ("Other" %in% unique(datatable$allele)) {
        datatable <- datatable[-which(datatable$allele == "Other"),]
      }

      # use Rcpp for processing
      output <- seglogoC(datatable, outputtemp)

      if (plot) {
        # reformat data
        plottable <- matrix(nrow=5, ncol=dim(output)[1])
        rownames(plottable) <- c("A","C","G","T","N")
        plottable["A",] <- t(output$A)
        plottable["T",] <- t(output$T)
        plottable["G",] <- t(output$G)
        plottable["C",] <- t(output$C)
        plottable["N",] <- t(output$N)

        # Create custom colour scheme
        cscustom <- ggseqlogo::make_col_scheme(chars=c("A", "C", "G", "T", "N"), groups=c("A", "C", "G", "T", "N"),
                                               cols=c('darkgreen', 'blue', 'orange', 'red', "#CCCCCC"))

        # plot using 'ggseqlogo' package
        p1 <- ggseqlogo::ggseqlogo(plottable, namespace='ACTGN', method = 'prob', col_scheme=cscustom) +
          ggplot2::theme(axis.text.y = ggplot2::element_text(size = axis.text.size),
                         axis.text.x = ggplot2::element_blank(),
                         axis.title.x = ggplot2::element_text(vjust = -0.5),
                         axis.title.y = ggplot2::element_text(size = axis.text.size+2),
                         legend.position="none")

        # plot the reference too
        aln <- data.frame(
          letter = strsplit(ref, "")[[1]],
          seqs = "Ref",
          x       = 1:nchar(paste(ref))
        )

        p2 <- ggplot2::ggplot(aln, ggplot2::aes(x, seqs)) +
          ggplot2::geom_text(ggplot2::aes(label=letter)) +
          ggplot2::xlab('') + ggseqlogo::theme_logo() + ggplot2::ylab('Sequence') +
          ggplot2::scale_x_continuous(expand = c(0.105, 0), breaks = 1:nchar(paste(ref)), labels = output$relpos) +
          ggplot2::theme(legend.position = 'none',
                         axis.text.y = ggplot2::element_text(size = axis.text.size),
                         axis.title.y = ggplot2::element_text(size = axis.text.size+2))

        # Combine using cowplot
        p <- cowplot::plot_grid(p1, p2, ncol = 1, align = 'v', rel_heights = c(5,1))

        return(p)

      } else {
        return(output)

      }

    } # end file excists

  } # end sample.id and gene.id

}

AlleleProfileR.labelwrapper <- function(x) {
  # condens insertions
  x <- stringr::str_replace_all(x, "ins([[:alpha:]]+)", "ins[+]")

  # insert newlines
  temp <- gsub('(.{1,20})(\\.|$)', '\\1. \n ', x)
  return(substr(temp, 1, nchar(temp)-4))
}

#' @title Histogram of the read-depth
#' @description This function determines the read-depth of a sample and gene combination.
#' @inheritParams AlleleProfileR.plot
#' @inheritParams AlleleProfileR.plot.alignment
#' @inheritParams AlleleProfileR.batch.summary
#' @return Histogram plot and data table
#' @author Arne Bruyneel
#' @export
AlleleProfileR.plot.readdept <- function(config, sample.id = NA, gene.id = NA, plot = TRUE, table = FALSE) {
  # config
  samplestable <- config[[1]][sample.id,]
  genestable <- config[[2]][gene.id,]

  # get the reads
  bamobj <- AlleleProfileR.bam(paste(samplestable$bam[1], sep=""))
  bamtable <- AlleleProfileR.getreads(bamobj, genestable$Chr[1], pcrrange = c(genestable$PCRStart[1], genestable$PCRStop[1]), range = c(genestable$Start[1], genestable$Stop[1]), purify = T)

  # range
  lower <- genestable$PCRStart
  upper <- genestable$PCRStop

  # if there is suiatble data
  if (dim(bamtable)[1] > 0) {
    # use Rcpp
    positionsidentified <- readdeptc(bamtable, range = c(lower:upper))

    # format data
    readhist <-list(breaks=positionsidentified$pos, counts=positionsidentified$counts, xname="Base position")
    class(readhist) <- "histogram"

    # plot?
    if (plot) {
      plot(readhist, main = "")
    }
    # table?
    if (table) {
      return(readhist)
    }

  } else {
    stop("No suitable data!")
  }
}

